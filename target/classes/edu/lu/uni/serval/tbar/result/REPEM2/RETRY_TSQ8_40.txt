RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"withIntOffset\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int lastSize = session.size, withIntOffset = lb.offset + 1;
red_line===
withIntOffset
start_offset===
37
end_offset===
50
Python OUTPUT===
int lastSize = session.size, withIntOffset = lb.offset + 1;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(charsetName + " not supported?", e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(charsetName + " not supported?", e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.ISO_8859_1
scn.ruleId===
4719
scn.suspCodeStr===
return bytes.getBytes("ISO-8859-1");
red_line===
"ISO-8859-1"
start_offset===
34
end_offset===
46
Python OUTPUT===
 return bytes.getBytes("ISO-8859-1"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this assert with a proper check.
scn.ruleId===
4274
scn.suspCodeStr===
assert out != null;
red_line===
assert out != null;
start_offset===
8
end_offset===
27
Python OUTPUT===
 assert out != null; 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8"));
red_line===
"UTF-8"
start_offset===
60
end_offset===
67
Python OUTPUT===
 byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"bytes\" which hides the field declared at line 110.
scn.ruleId===
1117
scn.suspCodeStr===
final byte[] bytes = this.bytes;
red_line===
bytes
start_offset===
21
end_offset===
26
Python OUTPUT===
final byte[] bytes = this.bytes;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"len\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int offset = 0, len;
red_line===
len
start_offset===
24
end_offset===
27
Python OUTPUT===
int offset = 0, len;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unused \"dinResult\" local variable.
scn.ruleId===
1481
scn.suspCodeStr===
String dinResult = din.readUTF();
red_line===
dinResult
start_offset===
19
end_offset===
28
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String s2 = new String(b2, "UTF-8");
red_line===
"UTF-8"
start_offset===
35
end_offset===
42
Python OUTPUT===
 String s2 = new String(b2, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] builtin = str.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
49
end_offset===
56
Python OUTPUT===
 byte[] builtin = str.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.US_ASCII
scn.ruleId===
4719
scn.suspCodeStr===
String strBuiltin = new String(builtin, "ASCII");
red_line===
"ASCII"
start_offset===
48
end_offset===
55
Python OUTPUT===
 String strBuiltin = new String(builtin, "ASCII"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] builtin = str.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
49
end_offset===
56
Python OUTPUT===
 byte[] builtin = str.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String strBuiltin = new String(builtin, "UTF-8");
red_line===
"UTF-8"
start_offset===
48
end_offset===
55
Python OUTPUT===
 String strBuiltin = new String(builtin, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String strBuffered = new String(buffered, "UTF-8");
red_line===
"UTF-8"
start_offset===
50
end_offset===
57
Python OUTPUT===
 String strBuffered = new String(buffered, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_flush = out2.toByteArray();
red_line===
buffered_needed_to_flush
start_offset===
19
end_offset===
43
Python OUTPUT===
byte[] buffered_needed_to_flush = out2.toByteArray();
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"inner2\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("inner2", request) == fooInner);
red_line===
"inner2"
start_offset===
35
end_offset===
43
Python OUTPUT===
assertTrue(getMessageField("inner2", request) == fooInner);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"deeper1\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("deeper1", request) == fooDeeper);
red_line===
"deeper1"
start_offset===
35
end_offset===
44
Python OUTPUT===
assertTrue(getMessageField("deeper1", request) == fooDeeper);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"deeper2\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("deeper2", request) == fooDeeper);
red_line===
"deeper2"
start_offset===
35
end_offset===
44
Python OUTPUT===
assertTrue(getMessageField("deeper2", request) == fooDeeper);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"inner1\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("inner1", request) == fooInner);
red_line===
"inner1"
start_offset===
35
end_offset===
43
Python OUTPUT===
assertTrue(getMessageField("inner1", request) == fooInner);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"deeper3\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("deeper3", request) == jpFooDeeper);
red_line===
"deeper3"
start_offset===
35
end_offset===
44
Python OUTPUT===
assertTrue(getMessageField("deeper3", request) == jpFooDeeper);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Config\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
Annotation messageConfig = test.getAnnotation("Config");
red_line===
"Config"
start_offset===
54
end_offset===
62
Python OUTPUT===
Annotation messageConfig = test.getAnnotation("Config");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"default\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(test.getField("default").number == 31);
red_line===
"default"
start_offset===
33
end_offset===
42
Python OUTPUT===
assertTrue(test.getField("default").number == 31);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Field<?>> fields = new LinkedHashMap<String, Field<?>>();
red_line===
<String, Field<?>>
start_offset===
68
end_offset===
86
Python OUTPUT===
<> = new LinkedHashMap < String , Field < ? >> ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"fqcn_message\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(fqcn.getValue("fqcn_message") == listRequest);
red_line===
"fqcn_message"
start_offset===
33
end_offset===
47
Python OUTPUT===
assertTrue(fqcn.getValue("fqcn_message") == listRequest);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"imported_enum\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(imported.getValue("imported_enum") == importedGender);
red_line===
"imported_enum"
start_offset===
37
end_offset===
52
Python OUTPUT===
assertTrue(imported.getValue("imported_enum") == importedGender);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"deeper\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(local.getValue("deeper") == tire);
red_line===
"deeper"
start_offset===
34
end_offset===
42
Python OUTPUT===
assertTrue(local.getValue("deeper") == tire);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"fqcn_enum\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(fqcn.getValue("fqcn_enum") == importedGender);
red_line===
"fqcn_enum"
start_offset===
33
end_offset===
44
Python OUTPUT===
assertTrue(fqcn.getValue("fqcn_enum") == importedGender);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"local_enum\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(local.getValue("local_enum") == localGender);
red_line===
"local_enum"
start_offset===
34
end_offset===
46
Python OUTPUT===
assertTrue(local.getValue("local_enum") == localGender);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"nested\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(local.getValue("nested") == part);
red_line===
"nested"
start_offset===
34
end_offset===
42
Python OUTPUT===
assertTrue(local.getValue("nested") == part);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
out[i++] = (byte) ((right & 0x0F) | (left << 4 & 0xF0));
red_line===
i
start_offset===
16
end_offset===
17
Python OUTPUT===
out[i++] = (byte) ((right & 0x0F) | (left << 4 & 0xF0));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"returnType\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Message argType, returnType;
red_line===
returnType
start_offset===
25
end_offset===
35
Python OUTPUT===
Message argType, returnType;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"argPackage\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final String argName, argPackage, retName, retPackage;
red_line===
argPackage
start_offset===
30
end_offset===
40
Python OUTPUT===
final String argName, argPackage, retName, retPackage;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this redundant jump.
scn.ruleId===
3626
scn.suspCodeStr===
continue;
red_line===
continue;
start_offset===
16
end_offset===
25
Python OUTPUT===

isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"appendUnderscore\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
boolean toLower = false, appendUnderscore = false;
red_line===
appendUnderscore
start_offset===
33
end_offset===
49
Python OUTPUT===
boolean toLower = false, appendUnderscore = false;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
c = name.charAt(i++);
red_line===
i
start_offset===
28
end_offset===
29
Python OUTPUT===
c = name.charAt(i++);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
char c = name.charAt(i++);
red_line===
i
start_offset===
33
end_offset===
34
Python OUTPUT===
char c = name.charAt(i++);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"destination\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final LinkedHashMap<String, Object> source, destination;
red_line===
destination
start_offset===
48
end_offset===
59
Python OUTPUT===
final LinkedHashMap<String, Object> source, destination;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strProtobufRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strProtobufRoundTrip = STRING.deser(protobufRoundTrip);
red_line===
= STRING.deser(protobufRoundTrip)
start_offset===
36
end_offset===
69
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Do not forget to remove this deprecated code someday.
scn.ruleId===
1133
scn.suspCodeStr===
String alias;
red_line===
alias
start_offset===
15
end_offset===
20
Python OUTPUT===
String alias;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Do not forget to remove this deprecated code someday.
scn.ruleId===
1133
scn.suspCodeStr===
String alias;
red_line===
alias
start_offset===
15
end_offset===
20
Python OUTPUT===
String alias;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new HashMap<K, V>();
red_line===
<K, V>
start_offset===
26
end_offset===
32
Python OUTPUT===
<> > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
TreeMap<String, String> tm = new TreeMap<String, String>();
red_line===
<String, String>
start_offset===
52
end_offset===
68
Python OUTPUT===
<> tm = new TreeMap < String , String > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"number\".
scn.ruleId===
1854
scn.suspCodeStr===
final int number = input.readFieldNumber(pipeSchema.wrappedSchema);
red_line===
= input.readFieldNumber(pipeSchema.wrappedSchema)
start_offset===
25
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
constructor.setAccessible(true);
red_line===
constructor.setAccessible(true)
start_offset===
12
end_offset===
43
Python OUTPUT===
constructor.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Double\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Double(input.readDouble());
red_line===
Double
start_offset===
23
end_offset===
29
Python OUTPUT===
 return new Double(inpuDouble()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setBoolean(message, input.readBool());
red_line===
f.setBoolean(message, input.readBool())
start_offset===
28
end_offset===
67
Python OUTPUT===
f.setBoolean(message, input.readBool());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
static final IdentityHashMap<Class<?>, Integer> __nonPublicCollections = new IdentityHashMap<Class<?>, Integer>();
red_line===
<Class<?>, Integer>
start_offset===
96
end_offset===
115
Python OUTPUT===
<> _ _ nonPublicCollections = new IdentityHashMap < Class < ? > , Integer > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"element\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
fSingletonSet_element = cSingletonSet.getDeclaredField("element");
red_line===
"element"
start_offset===
67
end_offset===
76
Python OUTPUT===
fSingletonSet_element = cSingletonSet.getDeclaredField("element");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"number\".
scn.ruleId===
1854
scn.suspCodeStr===
final int number = input.readFieldNumber(pipeSchema.wrappedSchema);
red_line===
= input.readFieldNumber(pipeSchema.wrappedSchema)
start_offset===
25
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Corrupt input.\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
throw new ProtostuffException("Corrupt input.");
red_line===
"Corrupt input."
start_offset===
46
end_offset===
62
Python OUTPUT===
throw new ProtostuffException("Corrupt input.");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Corrupt input.\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
throw new ProtostuffException("Corrupt input.");
red_line===
"Corrupt input."
start_offset===
46
end_offset===
62
Python OUTPUT===
throw new ProtostuffException("Corrupt input.");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Extract this nested ternary operation into an independent statement.
scn.ruleId===
3358
scn.suspCodeStr===
return (x < y) ? -1 : ((x == y) ? 0 : 1);
red_line===
(x == y) ? 0 : 1
start_offset===
35
end_offset===
51
Python OUTPUT===
return (x < y) ? -1 : ((x == y) ? 0 : 1);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"number\".
scn.ruleId===
1854
scn.suspCodeStr===
final int number = input.readFieldNumber(pipeSchema.wrappedSchema);
red_line===
= input.readFieldNumber(pipeSchema.wrappedSchema)
start_offset===
25
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"id\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final int arrayId = input.readUInt32(), id = ArraySchemas.toInlineId(arrayId);
red_line===
id
start_offset===
56
end_offset===
58
Python OUTPUT===
final int arrayId = input.readUInt32(), id = ArraySchemas.toInlineId(arrayId);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"eio\".
scn.ruleId===
1854
scn.suspCodeStr===
final EnumIO<?> eio = strategy.resolveEnumFrom(input);
red_line===
= strategy.resolveEnumFrom(input)
start_offset===
36
end_offset===
69
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
8
end_offset===
29
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
SampleClass _clazz = new SampleClass();
red_line===
_clazz
start_offset===
20
end_offset===
26
Python OUTPUT===
SampleClass _clazz = new SampleClass();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("ctrl len = " + controlData.length);
red_line===
System.out
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.out.println("ctrl len = " + controlData.length); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("test len = " + testByteArray.length);
red_line===
System.out
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.out.println("test len = " + testByteArray.length); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("test size() = " + lcpo.buffer.size());
red_line===
System.out
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.out.println("test size() = " + lcpo.buffer.size()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("test buff count = " + lcpo.buffer.buffers.size());
red_line===
System.out
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.out.println("test buff count = " + lcpo.buffer.buffers.size()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Foo> foos = new ArrayList<Foo>();
red_line===
<Foo>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> foos = new ArrayList < Foo > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
assertEquals(strComputed, new String(buffered, "UTF-8"));
red_line===
"UTF-8"
start_offset===
55
end_offset===
62
Python OUTPUT===
 assertEquals(strComputed, new String(buffered, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
assertEquals(strComputed, new String(streamed, "UTF-8"));
red_line===
"UTF-8"
start_offset===
55
end_offset===
62
Python OUTPUT===
 assertEquals(strComputed, new String(streamed, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String strComputed = new String(computed, "UTF-8");
red_line===
"UTF-8"
start_offset===
50
end_offset===
57
Python OUTPUT===
 String strComputed = new String(computed, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
assertEquals(strComputed, new String(buffered, "UTF-8"));
red_line===
"UTF-8"
start_offset===
55
end_offset===
62
Python OUTPUT===
 assertEquals(strComputed, new String(buffered, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
assertEquals(strComputed, new String(streamed, "UTF-8"));
red_line===
"UTF-8"
start_offset===
55
end_offset===
62
Python OUTPUT===
 assertEquals(strComputed, new String(streamed, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException("Truncated.", ProtobufException.truncatedMessage(ae));
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException("Truncated.", ProtobufException.truncatedMessage(ae));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] strbytes = value.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
52
end_offset===
59
Python OUTPUT===
 byte[] strbytes = value.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make buffer a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public LinkBuffer buffer;
red_line===
buffer
start_offset===
22
end_offset===
28
Python OUTPUT===
public static final LinkBuffer buffer ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] strbytes = value.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
52
end_offset===
59
Python OUTPUT===
 byte[] strbytes = value.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
private int offset, limit, lastTag = 0;
red_line===
limit
start_offset===
24
end_offset===
29
Python OUTPUT===
private int offset, limit, lastTag = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"offset\" which hides the field declared at line 47.
scn.ruleId===
1117
scn.suspCodeStr===
final int offset = this.offset;
red_line===
offset
start_offset===
18
end_offset===
24
Python OUTPUT===
final int offset = this.offset;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"buffer\" which hides the field declared at line 46.
scn.ruleId===
1117
scn.suspCodeStr===
final byte[] buffer = this.buffer;
red_line===
buffer
start_offset===
21
end_offset===
27
Python OUTPUT===
final byte[] buffer = this.buffer;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"offset\" which hides the field declared at line 47.
scn.ruleId===
1117
scn.suspCodeStr===
int offset = this.offset;
red_line===
offset
start_offset===
12
end_offset===
18
Python OUTPUT===
int offset = this.offset;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"buffer\" which hides the field declared at line 46.
scn.ruleId===
1117
scn.suspCodeStr===
final byte[] buffer = this.buffer;
red_line===
buffer
start_offset===
21
end_offset===
27
Python OUTPUT===
final byte[] buffer = this.buffer;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"offset\" which hides the field declared at line 47.
scn.ruleId===
1117
scn.suspCodeStr===
int offset = this.offset;
red_line===
offset
start_offset===
12
end_offset===
18
Python OUTPUT===
int offset = this.offset;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"buffer\" which hides the field declared at line 46.
scn.ruleId===
1117
scn.suspCodeStr===
final byte[] buffer = this.buffer;
red_line===
buffer
start_offset===
21
end_offset===
27
Python OUTPUT===
final byte[] buffer = this.buffer;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"offset\" which hides the field declared at line 47.
scn.ruleId===
1117
scn.suspCodeStr===
int offset = this.offset;
red_line===
offset
start_offset===
12
end_offset===
18
Python OUTPUT===
int offset = this.offset;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Extract the assignment out of this expression.
scn.ruleId===
1121
scn.suspCodeStr===
result |= (tmp = buffer[offset++]) << 28;
red_line===
=
start_offset===
35
end_offset===
36
Python OUTPUT===
result |= (tmp = buffer[offset++]) << 28;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"module\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
enumBlock.setAttribute("module", module);
red_line===
"module"
start_offset===
35
end_offset===
43
Python OUTPUT===
enumBlock.setAttribute("module", module);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \".java\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
Writer writer = CompilerUtil.newWriter(module, javaPackageName, eg.getName() + ".java");
red_line===
".java"
start_offset===
91
end_offset===
98
Python OUTPUT===
Writer writer = CompilerUtil.newWriter(module, javaPackageName, eg.getName() + ".java");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"message\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
messageBlock.setAttribute("message", m);
red_line===
"message"
start_offset===
42
end_offset===
51
Python OUTPUT===
messageBlock.setAttribute("message", m);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"options\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
enumBlock.setAttribute("options", module.getOptions());
red_line===
"options"
start_offset===
35
end_offset===
44
Python OUTPUT===
enumBlock.setAttribute("options", module.getOptions());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<File> files = new ArrayList<File>();
red_line===
<File>
start_offset===
40
end_offset===
46
Python OUTPUT===
<> files = new ArrayList < File > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println("  java -cp -jar protostuff-compiler.jar modules.properties");
red_line===
System.err
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.err.println(" java -cp -jar protostuff-compiler.jar modules.properties"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println("\nTo generate code for multiple modules:");
red_line===
System.err
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.err.println("\nTo generate code for multiple modules:"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"openBracketIndex\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int messageIndex = -1, openBracketIndex = -1;
red_line===
openBracketIndex
start_offset===
31
end_offset===
47
Python OUTPUT===
int messageIndex = -1, openBracketIndex = -1;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"aend\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int astart = -1, aend = 0;
red_line===
aend
start_offset===
25
end_offset===
29
Python OUTPUT===
int astart = -1, aend = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"ie\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int is = matcher.start(1), ie = matcher.end(1);
red_line===
ie
start_offset===
39
end_offset===
41
Python OUTPUT===
int is = matcher.start(1), ie = matcher.end(1);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"ie\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int is = matcher.start() + indent.start(1), ie = matcher.start() + indent.end(1);
red_line===
ie
start_offset===
60
end_offset===
62
Python OUTPUT===
int is = matcher.start() + indent.start(1), ie = matcher.start() + indent.end(1);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Use try-with-resources or close this \"BufferedReader\" in a \"finally\" clause.
scn.ruleId===
2095
scn.suspCodeStr===
BufferedReader reader = new BufferedReader(new FileReader(proto.getFile()));
red_line===
new BufferedReader(new FileReader(proto.getFile()))
start_offset===
32
end_offset===
83
Python OUTPUT===
BufferedReader reader = new BufferedReader(new FileReader(proto.getFile()));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"someFoo\" 10 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "someFoo", "some_foo");
red_line===
"someFoo"
start_offset===
18
end_offset===
27
Python OUTPUT===
verify(f, "someFoo", "some_foo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"SOME_FOO\" 5 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "SOME_FOO", "someFoo");
red_line===
"SOME_FOO"
start_offset===
18
end_offset===
28
Python OUTPUT===
verify(f, "SOME_FOO", "someFoo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"someFoo_\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "someFoo_", "some_foo");
red_line===
"someFoo_"
start_offset===
18
end_offset===
28
Python OUTPUT===
verify(f, "someFoo_", "some_foo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Some Foo\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "Some Foo", "someFoo");
red_line===
"Some Foo"
start_offset===
18
end_offset===
28
Python OUTPUT===
verify(f, "Some Foo", "someFoo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"money\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("money", PLURAL.format("money"));
red_line===
"money"
start_offset===
21
end_offset===
28
Python OUTPUT===
assertEquals("money", PLURAL.format("money"));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"SomeFoo\" 10 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "someFoo", "SomeFoo");
red_line===
"SomeFoo"
start_offset===
29
end_offset===
38
Python OUTPUT===
verify(f, "someFoo", "SomeFoo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"history\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("history", SINGULAR.format("histories"));
red_line===
"history"
start_offset===
21
end_offset===
30
Python OUTPUT===
assertEquals("history", SINGULAR.format("histories"));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"playerInfo\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("playerInfo", SINGULAR.format("playerInfo"));
red_line===
"playerInfo"
start_offset===
21
end_offset===
33
Python OUTPUT===
assertEquals("playerInfo", SINGULAR.format("playerInfo"));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"some_foo_\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
verify(f, "some_foo_", "someFoo");
red_line===
"some_foo_"
start_offset===
18
end_offset===
29
Python OUTPUT===
verify(f, "some_foo_", "someFoo");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(msgpack);
red_line===
= new ByteArrayInputStream(msgpack)
start_offset===
40
end_offset===
75
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strXmlRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strXmlRoundTrip = STRING.deser(xmlRoundTrip);
red_line===
= STRING.deser(xmlRoundTrip)
start_offset===
31
end_offset===
59
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"writer\" which hides the field declared at line 36.
scn.ruleId===
1117
scn.suspCodeStr===
final XMLStreamWriter writer = this.writer;
red_line===
writer
start_offset===
30
end_offset===
36
Python OUTPUT===
final XMLStreamWriter writer = this.writer;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"xmlStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml);
red_line===
= new ByteArrayInputStream(xml)
start_offset===
39
end_offset===
70
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"xml\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] xml = XmlIOUtil.toByteArray(message, schema);
red_line===
= XmlIOUtil.toByteArray(message, schema)
start_offset===
19
end_offset===
59
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"msgpack\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] msgpack = MsgpackIOUtil.toByteArray(message, schema, numeric);
red_line===
= MsgpackIOUtil.toByteArray(message, schema, numeric)
start_offset===
23
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(json);
red_line===
= new ByteArrayInputStream(json)
start_offset===
40
end_offset===
72
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"json\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] json = JsonXIOUtil.toByteArray(message, schema, isNumeric(), buf());
red_line===
= JsonXIOUtil.toByteArray(message, schema, isNumeric(), buf())
start_offset===
20
end_offset===
82
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"messageSmile\".
scn.ruleId===
1854
scn.suspCodeStr===
T messageSmile = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
23
end_offset===
44
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"messageSmileRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
T messageSmileRoundTrip = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
32
end_offset===
53
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"smileStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream smileStream = new ByteArrayInputStream(smile);
red_line===
= new ByteArrayInputStream(smile)
start_offset===
41
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"smileStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream smileStream = new ByteArrayInputStream(smile);
red_line===
= new ByteArrayInputStream(smile)
start_offset===
41
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strJsonRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strJsonRoundTrip = STRING.deser(jsonRoundTrip);
red_line===
= STRING.deser(jsonRoundTrip)
start_offset===
32
end_offset===
61
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(json);
red_line===
= new ByteArrayInputStream(json)
start_offset===
40
end_offset===
72
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"json\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] json = JsonXIOUtil.toByteArray(message, schema, isNumeric(), buf());
red_line===
= JsonXIOUtil.toByteArray(message, schema, isNumeric(), buf())
start_offset===
20
end_offset===
82
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(json);
red_line===
= new ByteArrayInputStream(json)
start_offset===
40
end_offset===
72
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuff\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protostuff = ProtostuffIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtostuffIOUtil.toByteArray(message, schema, buf())
start_offset===
26
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strJsonRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strJsonRoundTrip = STRING.deser(jsonRoundTrip);
red_line===
= STRING.deser(jsonRoundTrip)
start_offset===
32
end_offset===
61
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(json);
red_line===
= new ByteArrayInputStream(json)
start_offset===
40
end_offset===
72
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"json\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] json = JsonIOUtil.toByteArray(message, schema, isNumeric());
red_line===
= JsonIOUtil.toByteArray(message, schema, isNumeric())
start_offset===
20
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"token\".
scn.ruleId===
1854
scn.suspCodeStr===
final JsonToken token = parser.getCurrentToken();
red_line===
= parser.getCurrentToken()
start_offset===
38
end_offset===
64
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Foo> list = new ArrayList<Foo>();
red_line===
<Foo>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> list = new ArrayList < Foo > ( ) ;
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
Correct one of the identical sub-expressions on both sides of operator \"-\"
scn.ruleId===
1764
scn.suspCodeStr===
Assert.assertTrue(Math.abs(message.field4.inner2 - message.field4.inner2) < 0.001);
red_line===
message.field4.inner2
start_offset===
59
end_offset===
80
Python OUTPUT===
- abs ( message.field4.inner2 - message.field4.inner2 ) < 0.001 ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"jsonStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream jsonStream = new ByteArrayInputStream(msgpack);
red_line===
= new ByteArrayInputStream(msgpack)
start_offset===
40
end_offset===
75
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"msgpackStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream msgpackStream = new ByteArrayInputStream(msgpack);
red_line===
= new ByteArrayInputStream(msgpack)
start_offset===
43
end_offset===
78
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("@EXPLICIT");
red_line===
System.out
start_offset===
12
end_offset===
22
Python OUTPUT===
 System.out.println("@EXPLICIT"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuff\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protostuff = ProtostuffIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtostuffIOUtil.toByteArray(message, schema, buf())
start_offset===
26
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println("@INCREMENTAL");
red_line===
System.out
start_offset===
12
end_offset===
22
Python OUTPUT===
 System.out.println("@INCREMENTAL"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
private final List<Value> list = new ArrayList<Value>();
red_line===
<Value>
start_offset===
54
end_offset===
61
Python OUTPUT===
<> Value > list = new ArrayList < Value > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final boolean runTest;
red_line===
runTest
start_offset===
25
end_offset===
32
Python OUTPUT===
static final boolean runTest;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this field \"INSTANCE_COUNT\" to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
3008
scn.suspCodeStr===
static int INSTANCE_COUNT = 0;
red_line===
INSTANCE_COUNT
start_offset===
19
end_offset===
33
Python OUTPUT===
static int INSTANCE_COUNT = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final boolean runTest;
red_line===
runTest
start_offset===
25
end_offset===
32
Python OUTPUT===
static final boolean runTest;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this field \"INSTANCE_COUNT\" to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
3008
scn.suspCodeStr===
static int INSTANCE_COUNT = 0;
red_line===
INSTANCE_COUNT
start_offset===
19
end_offset===
33
Python OUTPUT===
static int INSTANCE_COUNT = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException("Serializing to a byte array threw an IOException", e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException("Serializing to a byte array threw an IOException", e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new DefaultInstantiator<T>(constructor);
red_line===
<T>
start_offset===
38
end_offset===
41
Python OUTPUT===
<> T > ( constructor ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new Android3Instantiator<T>(clazz);
red_line===
<T>
start_offset===
47
end_offset===
50
Python OUTPUT===
<> T > ( clazz ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new Android2Instantiator<T>(clazz);
red_line===
<T>
start_offset===
43
end_offset===
46
Python OUTPUT===
<> T > ( clazz ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,long[]> longHashMap = new HashMap<Integer,long[]>();
red_line===
<Integer,long[]>
start_offset===
57
end_offset===
73
Python OUTPUT===
<> longHashMap = new HashMap < Integer , long [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<short[]> shortArrayList = new ArrayList<short[]>();
red_line===
<short[]>
start_offset===
57
end_offset===
66
Python OUTPUT===
<> shortArrayList = new ArrayList < short [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<long[]> longArrayList = new ArrayList<long[]>();
red_line===
<long[]>
start_offset===
55
end_offset===
63
Python OUTPUT===
<> longArrayList = new ArrayList < long [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,double[]> doubleHashMap = new HashMap<Integer,double[]>();
red_line===
<Integer,double[]>
start_offset===
61
end_offset===
79
Python OUTPUT===
<> doubleHashMap = new HashMap < Integer , double [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Long[]> longArrayList = new ArrayList<Long[]>();
red_line===
<Long[]>
start_offset===
55
end_offset===
63
Python OUTPUT===
<> longArrayList = new ArrayList < Long [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,int[]> intHashMap = new HashMap<Integer,int[]>();
red_line===
<Integer,int[]>
start_offset===
55
end_offset===
70
Python OUTPUT===
<> intHashMap = new HashMap < Integer , int [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Short[]> shortArrayList = new ArrayList<Short[]>();
red_line===
<Short[]>
start_offset===
57
end_offset===
66
Python OUTPUT===
<> shortArrayList = new ArrayList < Short [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,float[]> floatHashMap = new HashMap<Integer,float[]>();
red_line===
<Integer,float[]>
start_offset===
59
end_offset===
76
Python OUTPUT===
<> floatHashMap = new HashMap < Integer , float [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,short[]> shortHashMap = new HashMap<Integer,short[]>();
red_line===
<Integer,short[]>
start_offset===
59
end_offset===
76
Python OUTPUT===
<> shortHashMap = new HashMap < Integer , short [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Float[]> floatArrayList = new ArrayList<Float[]>();
red_line===
<Float[]>
start_offset===
57
end_offset===
66
Python OUTPUT===
<> floatArrayList = new ArrayList < Float [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Float[]> floatHashMap = new HashMap<Integer,Float[]>();
red_line===
<Integer,Float[]>
start_offset===
59
end_offset===
76
Python OUTPUT===
<> floatHashMap = new HashMap < Integer , Float [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Integer[]> intArrayList = new ArrayList<Integer[]>();
red_line===
<Integer[]>
start_offset===
57
end_offset===
68
Python OUTPUT===
<> intArrayList = new ArrayList < Integer [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<boolean[]> boolArrayList = new ArrayList<boolean[]>();
red_line===
<boolean[]>
start_offset===
58
end_offset===
69
Python OUTPUT===
<> boolArrayList = new ArrayList < boolean [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Double[]> doubleHashMap = new HashMap<Integer,Double[]>();
red_line===
<Integer,Double[]>
start_offset===
61
end_offset===
79
Python OUTPUT===
<> doubleHashMap = new HashMap < Integer , Double [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Integer[]> intHashMap = new HashMap<Integer,Integer[]>();
red_line===
<Integer,Integer[]>
start_offset===
59
end_offset===
78
Python OUTPUT===
<> intHashMap = new HashMap < Integer , Integer [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final HashMap<String, Integer> fieldMap = new HashMap<String, Integer>();
red_line===
<String, Integer>
start_offset===
61
end_offset===
78
Python OUTPUT===
<> fieldMap = new HashMap < String , Integer > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Double[]> doubleArrayList = new ArrayList<Double[]>();
red_line===
<Double[]>
start_offset===
59
end_offset===
69
Python OUTPUT===
<> doubleArrayList = new ArrayList < Double [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,char[]> charHashMap = new HashMap<Integer,char[]>();
red_line===
<Integer,char[]>
start_offset===
57
end_offset===
73
Python OUTPUT===
<> charHashMap = new HashMap < Integer , char [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Object> list = new ArrayList<Object>();
red_line===
<Object>
start_offset===
46
end_offset===
54
Python OUTPUT===
<> list = new ArrayList < Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<double[]> doubleArrayList = new ArrayList<double[]>();
red_line===
<double[]>
start_offset===
59
end_offset===
69
Python OUTPUT===
<> doubleArrayList = new ArrayList < double [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<char[]> charArrayList = new ArrayList<char[]>();
red_line===
<char[]>
start_offset===
55
end_offset===
63
Python OUTPUT===
<> charArrayList = new ArrayList < char [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<float[]> floatArrayList = new ArrayList<float[]>();
red_line===
<float[]>
start_offset===
57
end_offset===
66
Python OUTPUT===
<> floatArrayList = new ArrayList < float [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<int[]> intArrayList = new ArrayList<int[]>();
red_line===
<int[]>
start_offset===
53
end_offset===
60
Python OUTPUT===
<> intArrayList = new ArrayList < int [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Long[]> longHashMap = new HashMap<Integer,Long[]>();
red_line===
<Integer,Long[]>
start_offset===
57
end_offset===
73
Python OUTPUT===
<> longHashMap = new HashMap < Integer , Long [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,boolean[]> boolHashMap = new HashMap<Integer,boolean[]>();
red_line===
<Integer,boolean[]>
start_offset===
60
end_offset===
79
Python OUTPUT===
<> boolHashMap = new HashMap < Integer , boolean [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Short[]> shortHashMap = new HashMap<Integer,Short[]>();
red_line===
<Integer,Short[]>
start_offset===
59
end_offset===
76
Python OUTPUT===
<> shortHashMap = new HashMap < Integer , Short [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondSet\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
LinkedHashSet firstSet, secondSet;
red_line===
secondSet
start_offset===
32
end_offset===
41
Python OUTPUT===
LinkedHashSet firstSet, secondSet;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<PojoWithEnumMap> list = new ArrayList<PojoWithEnumMap>();
red_line===
<PojoWithEnumMap>
start_offset===
50
end_offset===
67
Python OUTPUT===
<> list = new ArrayList < PojoWithEnumMap > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondEnumMap\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
EnumMap firstEnumMap, secondEnumMap;
red_line===
secondEnumMap
start_offset===
30
end_offset===
43
Python OUTPUT===
EnumMap firstEnumMap, secondEnumMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondMap\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
LinkedHashMap firstMap, secondMap;
red_line===
secondMap
start_offset===
32
end_offset===
41
Python OUTPUT===
LinkedHashMap firstMap, secondMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"foo\" which hides the field declared at line 35.
scn.ruleId===
1117
scn.suspCodeStr===
Foo foo = new Foo();
red_line===
foo
start_offset===
12
end_offset===
15
Python OUTPUT===
Foo foo = new Foo();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Bar> bars = new ArrayList<Bar>();
red_line===
<Bar>
start_offset===
43
end_offset===
48
Python OUTPUT===
<> bars = new ArrayList < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"bar\" which hides the field declared at line 45.
scn.ruleId===
1117
scn.suspCodeStr===
Bar bar = new Bar();
red_line===
bar
start_offset===
12
end_offset===
15
Python OUTPUT===
Bar bar = new Bar();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"bar\" which hides the field declared at line 45.
scn.ruleId===
1117
scn.suspCodeStr===
Bar bar = new Bar();
red_line===
bar
start_offset===
12
end_offset===
15
Python OUTPUT===
Bar bar = new Bar();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"bar\" which hides the field declared at line 45.
scn.ruleId===
1117
scn.suspCodeStr===
Bar bar = new Bar();
red_line===
bar
start_offset===
12
end_offset===
15
Python OUTPUT===
Bar bar = new Bar();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"foo\" which hides the field declared at line 35.
scn.ruleId===
1117
scn.suspCodeStr===
Foo foo = new Foo();
red_line===
foo
start_offset===
12
end_offset===
15
Python OUTPUT===
Foo foo = new Foo();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<String, EnumMap<Sequence, Integer>> map = new HashMap<String, EnumMap<Sequence, Integer>>();
red_line===
<String, EnumMap<Sequence, Integer>>
start_offset===
73
end_offset===
109
Python OUTPUT===
<> HashMap < String , EnumMap < Sequence , Integer >> ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> extraOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
72
end_offset===
88
Python OUTPUT===
<> extraOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> standardOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
75
end_offset===
91
Python OUTPUT===
<> standardOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"returnType\" which hides the field declared at line 193.
scn.ruleId===
1117
scn.suspCodeStr===
Message returnType = proto.findMessageReference(fullReturnName, enclosingNs);
red_line===
returnType
start_offset===
24
end_offset===
34
Python OUTPUT===
Message returnType = proto.findMessageReference(fullReturnName, enclosingNs);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"argType\" which hides the field declared at line 193.
scn.ruleId===
1117
scn.suspCodeStr===
Message argType = proto.findMessageReference(fullArgName, enclosingNs);
red_line===
argType
start_offset===
24
end_offset===
31
Python OUTPUT===
Message argType = proto.findMessageReference(fullArgName, enclosingNs);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, RpcMethod> rpcMethods = new LinkedHashMap<String, RpcMethod>();
red_line===
<String, RpcMethod>
start_offset===
73
end_offset===
92
Python OUTPUT===
<> rpcMethods = new LinkedHashMap < String , RpcMethod > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> standardOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
75
end_offset===
91
Python OUTPUT===
<> standardOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> standardOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
79
end_offset===
95
Python OUTPUT===
<> standardOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> extraOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
72
end_offset===
88
Python OUTPUT===
<> extraOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> extraOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
76
end_offset===
92
Python OUTPUT===
<> extraOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final ArrayList<Extension> extensions = new ArrayList<Extension>();
red_line===
<Extension>
start_offset===
57
end_offset===
68
Python OUTPUT===
<> > extensions = new ArrayList < Extension > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final ArrayList<String> docs = new ArrayList<String>();
red_line===
<String>
start_offset===
48
end_offset===
56
Python OUTPUT===
<> > docs = new ArrayList < String > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Proto> importedProtos = new LinkedHashMap<String, Proto>();
red_line===
<String, Proto>
start_offset===
73
end_offset===
88
Python OUTPUT===
<> importedProtos = new LinkedHashMap < String , Proto > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
public Proto load(String path, Proto importer) throws Exception;
red_line===
Exception
start_offset===
62
end_offset===
71
Python OUTPUT===
public Proto load(String path, Proto importer) throws Exception;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> standardOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
75
end_offset===
91
Python OUTPUT===
<> standardOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
this.javaPackageName = new Mutable<String>(javaPackageName);
red_line===
<String>
start_offset===
42
end_offset===
50
Python OUTPUT===
<> new Mutable < String > ( javaPackageName ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final ArrayList<ConfiguredReference> references = new ArrayList<ConfiguredReference>();
red_line===
<ConfiguredReference>
start_offset===
67
end_offset===
88
Python OUTPUT===
<> > references = new ArrayList < ConfiguredReference > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, EnumGroup> enumGroups = new LinkedHashMap<String, EnumGroup>();
red_line===
<String, EnumGroup>
start_offset===
73
end_offset===
92
Python OUTPUT===
<> enumGroups = new LinkedHashMap < String , EnumGroup > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Message> messages = new LinkedHashMap<String, Message>();
red_line===
<String, Message>
start_offset===
69
end_offset===
86
Python OUTPUT===
<> messages = new LinkedHashMap < String , Message > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, EnumGroup> fullyQualifiedEnumGroups = new LinkedHashMap<String, EnumGroup>();
red_line===
<String, EnumGroup>
start_offset===
87
end_offset===
106
Python OUTPUT===
<> fullyQualifiedEnumGroups = new LinkedHashMap < String , EnumGroup > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> extraOptions = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
72
end_offset===
88
Python OUTPUT===
<> extraOptions = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Service> services = new LinkedHashMap<String, Service>();
red_line===
<String, Service>
start_offset===
69
end_offset===
86
Python OUTPUT===
<> services = new LinkedHashMap < String , Service > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Message> fullyQualifiedMessages = new LinkedHashMap<String, Message>();
red_line===
<String, Message>
start_offset===
83
end_offset===
100
Python OUTPUT===
<> fullyQualifiedMessages = new LinkedHashMap < String , Message > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"javaPackageName\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Mutable<String> packageName, javaPackageName;
red_line===
javaPackageName
start_offset===
33
end_offset===
48
Python OUTPUT===
Mutable<String> packageName, javaPackageName;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
LinkedList<String> ll = new LinkedList<String>();
red_line===
<String>
start_offset===
50
end_offset===
58
Python OUTPUT===
<> ll = new LinkedList < String > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"o2\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Object o1, o2;
red_line===
o2
start_offset===
19
end_offset===
21
Python OUTPUT===
Object o1, o2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println("registered delegate: ImmutableListAsDelegate<Baz>");
red_line===
System.err
start_offset===
16
end_offset===
26
Python OUTPUT===
 System.err.println("registered delegate: ImmutableListAsDelegate<Baz>"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this array creation and simply pass the elements.
scn.ruleId===
3878
scn.suspCodeStr===
List<Integer> intFirst = newList(new Integer[] { 1, 2, 3, 4 });
red_line===
new Integer[] { 1, 2, 3, 4 }
start_offset===
45
end_offset===
73
Python OUTPUT===
 List<Integer> intFirst = newList(new Integer
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<T> list = new ArrayList<T>();
red_line===
<T>
start_offset===
45
end_offset===
48
Python OUTPUT===
<> list = new ArrayList < T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Character[]> charHashMap = new HashMap<Integer,Character[]>();
red_line===
<Integer,Character[]>
start_offset===
62
end_offset===
83
Python OUTPUT===
<> charHashMap = new HashMap < Integer , Character [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashMap<Integer,Boolean[]> boolHashMap = new HashMap<Integer,Boolean[]>();
red_line===
<Integer,Boolean[]>
start_offset===
60
end_offset===
79
Python OUTPUT===
<> boolHashMap = new HashMap < Integer , Boolean [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Boolean[]> boolArrayList = new ArrayList<Boolean[]>();
red_line===
<Boolean[]>
start_offset===
58
end_offset===
69
Python OUTPUT===
<> boolArrayList = new ArrayList < Boolean [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<Character[]> charArrayList = new ArrayList<Character[]>();
red_line===
<Character[]>
start_offset===
60
end_offset===
73
Python OUTPUT===
<> charArrayList = new ArrayList < Character [ ] > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unnecessary cast to \"char\".
scn.ruleId===
1905
scn.suspCodeStr===
int codePoint = Character.toCodePoint((char) c, (char) str.charAt(i));
red_line===
char
start_offset===
65
end_offset===
69
Python OUTPUT===
 int codePoint = Character.toCodePoint((char) c, str.charAt( i));
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"buffered\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] buffered = session.toByteArray();
red_line===
= session.toByteArray()
start_offset===
24
end_offset===
47
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"offset\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int lastSize = session.size, offset = lb.offset, withIntOffset = offset + expectedSize;
red_line===
offset
start_offset===
37
end_offset===
43
Python OUTPUT===
int lastSize = session.size, offset = lb.offset, withIntOffset = offset + expectedSize;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
int digit = Character.digit(buffer[offset++], radix);
red_line===
offset
start_offset===
47
end_offset===
53
Python OUTPUT===
int digit = Character.digit(buffer[offset++], radix);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"b1\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
byte b0, b1, b2;
red_line===
b1
start_offset===
17
end_offset===
19
Python OUTPUT===
byte b0, b1, b2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"b1\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
byte b0, b1, b2;
red_line===
b1
start_offset===
21
end_offset===
23
Python OUTPUT===
byte b0, b1, b2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"b1\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
byte b0, b1, b2, b3;
red_line===
b1
start_offset===
17
end_offset===
19
Python OUTPUT===
byte b0, b1, b2, b3;
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
output[outOffset++] = (byte) (b2 << 6 | b3);
red_line===
b3
start_offset===
56
end_offset===
58
Python OUTPUT===
output[outOffset++] = (byte) (b2 << 6 | b3);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Extract this nested ternary operation into an independent statement.
scn.ruleId===
3358
scn.suspCodeStr===
return (a < b) ? -1 : ((a > b) ? 1 : 0);
red_line===
(a > b) ? 1 : 0
start_offset===
31
end_offset===
46
Python OUTPUT===
return (a < b) ? -1 : ((a > b) ? 1 : 0);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unnecessary cast to \"int\".
scn.ruleId===
1905
scn.suspCodeStr===
int ch2 = (int) buffer[offset + i - 2];
red_line===
int
start_offset===
31
end_offset===
34
Python OUTPUT===
 int ch2 = ( ) buffer[offset + i -2];
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
buffer[offset++] = (byte) (0xF0 | ((codePoint >> 18) & 0x07));
red_line===
offset
start_offset===
23
end_offset===
29
Python OUTPUT===
buffer[offset++] = (byte) (0xF0 | ((codePoint >> 18) & 0x07));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
buffer[offset++] = (byte) (0x80 | ((codePoint >> 6) & 0x3F));
red_line===
offset
start_offset===
23
end_offset===
29
Python OUTPUT===
buffer[offset++] = (byte) (0x80 | ((codePoint >> 6) & 0x3F));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"l4\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Object l3, l4;
red_line===
l4
start_offset===
19
end_offset===
21
Python OUTPUT===
Object l3, l4;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unnecessary cast to \"char\".
scn.ruleId===
1905
scn.suspCodeStr===
int codePoint = Character.toCodePoint((char) c, (char) str.charAt(i));
red_line===
char
start_offset===
65
end_offset===
69
Python OUTPUT===
 int codePoint = Character.toCodePoint((char) c, str.charAt( i));
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"len\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int contentSize = 0, len;
red_line===
len
start_offset===
29
end_offset===
32
Python OUTPUT===
int contentSize = 0, len;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
red_line===
limit
start_offset===
39
end_offset===
44
Python OUTPUT===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this array creation and simply pass the elements.
scn.ruleId===
3878
scn.suspCodeStr===
List<Size> enumThird = newList(new Size[] { Size.LARGE });
red_line===
new Size[] { Size.LARGE }
start_offset===
43
end_offset===
68
Python OUTPUT===
 List<Size> enumThird = newList(new Size[] 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unused \"lenB\" local variable.
scn.ruleId===
1481
scn.suspCodeStr===
int lenB = b.length();
red_line===
lenB
start_offset===
16
end_offset===
20
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unused \"x\" local variable.
scn.ruleId===
1481
scn.suspCodeStr===
boolean x = a.equals(b);
red_line===
x
start_offset===
20
end_offset===
21
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"h2\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final int h1 = bs.hash, h2 = other.hash;
red_line===
h2
start_offset===
36
end_offset===
38
Python OUTPUT===
final int h1 = bs.hash, h2 = other.hash;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
return new String(bytes.getBytes("ISO-8859-1"), "UTF-8");
red_line===
"UTF-8"
start_offset===
60
end_offset===
67
Python OUTPUT===
 return new String(bytes.getBytes("ISO-8859-1"), "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
assertEquals(surrogatePairs, new String(nativeSurrogatePairsSerialized, "UTF-8"));
red_line===
"UTF-8"
start_offset===
80
end_offset===
87
Python OUTPUT===
 assertEquals(surrogatePairs, new String(nativeSurrogatePairsSerialized, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unused \"buffered\" local variable.
scn.ruleId===
1481
scn.suspCodeStr===
byte[] buffered = session.toByteArray();
red_line===
buffered
start_offset===
15
end_offset===
23
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"UTF-8\" 7 times.
scn.ruleId===
1192
scn.suspCodeStr===
OutputStreamWriter writer = new OutputStreamWriter(bout, "UTF-8");
red_line===
"UTF-8"
start_offset===
65
end_offset===
72
Python OUTPUT===
OutputStreamWriter writer = new OutputStreamWriter(bout, "UTF-8");
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_grow = session2.toByteArray();
red_line===
buffered_needed_to_grow
start_offset===
19
end_offset===
42
Python OUTPUT===
byte[] buffered_needed_to_grow = session2.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_flush = out2.toByteArray();
red_line===
buffered_needed_to_flush
start_offset===
19
end_offset===
43
Python OUTPUT===
byte[] buffered_needed_to_flush = out2.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Immediately return this expression instead of assigning it to the temporary variable \"data\".
scn.ruleId===
1488
scn.suspCodeStr===
byte[] data = out.toByteArray();
red_line===
out.toByteArray()
start_offset===
22
end_offset===
39
Python OUTPUT===
byte[] data = out.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"foo\" which hides the field declared at line 35.
scn.ruleId===
1117
scn.suspCodeStr===
Foo foo = new Foo();
red_line===
foo
start_offset===
12
end_offset===
15
Python OUTPUT===
Foo foo = new Foo();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Immediately return this expression instead of assigning it to the temporary variable \"data\".
scn.ruleId===
1488
scn.suspCodeStr===
byte[] data = output.toByteArray();
red_line===
output.toByteArray()
start_offset===
22
end_offset===
42
Python OUTPUT===
byte[] data = output.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<String> strings = new ArrayList<String>();
red_line===
<String>
start_offset===
49
end_offset===
57
Python OUTPUT===
<> strings = new ArrayList < String > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"bar\" which hides the field declared at line 45.
scn.ruleId===
1117
scn.suspCodeStr===
Bar bar = new Bar();
red_line===
bar
start_offset===
12
end_offset===
15
Python OUTPUT===
Bar bar = new Bar();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<String> strings = new ArrayList<String>();
red_line===
<String>
start_offset===
49
end_offset===
57
Python OUTPUT===
<> strings = new ArrayList < String > ( ) ;
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"read\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int toRead = len - existing, read = 0;
red_line===
read
start_offset===
37
end_offset===
41
Python OUTPUT===
int toRead = len - existing, read = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Deeper\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
Message requestDeeper = requestInner.getNestedMessage("Deeper");
red_line===
"Deeper"
start_offset===
62
end_offset===
70
Python OUTPUT===
Message requestDeeper = requestInner.getNestedMessage("Deeper");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"inner3\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("inner3", request) == jpFooInner);
red_line===
"inner3"
start_offset===
35
end_offset===
43
Python OUTPUT===
assertTrue(getMessageField("inner3", request) == jpFooInner);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"inner3\" 5 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(getMessageField("inner3", requestInner) == jpFooInner);
red_line===
"inner3"
start_offset===
35
end_offset===
43
Python OUTPUT===
assertTrue(getMessageField("inner3", requestInner) == jpFooInner);
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Inner\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
Message requestInner = request.getNestedMessage("Inner");
red_line===
"Inner"
start_offset===
56
end_offset===
63
Python OUTPUT===
Message requestInner = request.getNestedMessage("Inner");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"fooBarBaz\" 7 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("fooBarBaz", toCamelCase("fooBarBaz").toString());
red_line===
"fooBarBaz"
start_offset===
21
end_offset===
32
Python OUTPUT===
assertEquals("fooBarBaz", toCamelCase("fooBarBaz").toString());
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Deeper\" 5 times.
scn.ruleId===
1192
scn.suspCodeStr===
Message responseDeeper = responseInner.getNestedMessage("Deeper");
red_line===
"Deeper"
start_offset===
64
end_offset===
72
Python OUTPUT===
Message responseDeeper = responseInner.getNestedMessage("Deeper");
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Inner\" 5 times.
scn.ruleId===
1192
scn.suspCodeStr===
Message responseInner = response.getNestedMessage("Inner");
red_line===
"Inner"
start_offset===
58
end_offset===
65
Python OUTPUT===
Message responseInner = response.getNestedMessage("Inner");
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"fooBarBaz\" 8 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("fooBarBaz", toCamelCase("foo_bar_baz").toString());
red_line===
"fooBarBaz"
start_offset===
21
end_offset===
32
Python OUTPUT===
assertEquals("fooBarBaz", toCamelCase("foo_bar_baz").toString());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Bool foo_some_boolean = (Field.Bool) foo.getField("some_boolean");
red_line===
foo_some_boolean
start_offset===
19
end_offset===
35
Python OUTPUT===
Field.Bool foo_some_boolean = (Field.Bool) foo.getField("some_boolean");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int32 bar_some_int = (Field.Int32) bar.getField("some_int");
red_line===
bar_some_int
start_offset===
20
end_offset===
32
Python OUTPUT===
Field.Int32 bar_some_int = (Field.Int32) bar.getField("some_int");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Double foo_some_double = (Field.Double) foo.getField("some_double");
red_line===
foo_some_double
start_offset===
21
end_offset===
36
Python OUTPUT===
Field.Double foo_some_double = (Field.Double) foo.getField("some_double");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new ImmutableList<T>(list);
red_line===
<T>
start_offset===
36
end_offset===
39
Python OUTPUT===
<> T > ( list ) ;
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
A \"NullPointerException\" could be thrown; \"bar_some_double\" is nullable here.
scn.ruleId===
2259
scn.suspCodeStr===
assertEquals(bar_some_double.defaultValue, Double.valueOf(45.123));
red_line===
bar_some_double.defaultValue
start_offset===
21
end_offset===
49
Python OUTPUT===
assertEquals(bar_some_double.defaultValue, Double.valueOf(45.123));
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
A \"NullPointerException\" could be thrown; \"bar_some_float\" is nullable here.
scn.ruleId===
2259
scn.suspCodeStr===
assertEquals(bar_some_float.defaultValue, Float.valueOf(127.0f));
red_line===
bar_some_float.defaultValue
start_offset===
21
end_offset===
48
Python OUTPUT===
assertEquals(bar_some_float.defaultValue, Float.valueOf(127.0f));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"value\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("MALE", defaultGender.getValue("value"));
red_line===
"value"
start_offset===
52
end_offset===
59
Python OUTPUT===
assertEquals("MALE", defaultGender.getValue("value"));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"nested_enum\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(local.getValue("nested_enum") == condition);
red_line===
"nested_enum"
start_offset===
34
end_offset===
47
Python OUTPUT===
assertTrue(local.getValue("nested_enum") == condition);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this array creation and simply pass the elements.
scn.ruleId===
3878
scn.suspCodeStr===
List<Integer> intSecond = newList(new Integer[] { 4, 5, 6, 7 });
red_line===
new Integer[] { 4, 5, 6, 7 }
start_offset===
46
end_offset===
74
Python OUTPUT===
 List<Integer> intSecond = newList(new Integer
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.out.println(msg);
red_line===
System.out
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.out.println(msg); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"imported_message\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(imported.getValue("imported_message") == person);
red_line===
"imported_message"
start_offset===
37
end_offset===
55
Python OUTPUT===
assertTrue(imported.getValue("imported_message") == person);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"imported_message\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(car.getOptions().get("imported_message") == person);
red_line===
"imported_message"
start_offset===
40
end_offset===
58
Python OUTPUT===
assertTrue(car.getOptions().get("imported_message") == person);
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"l4\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Object l3, l4;
red_line===
l4
start_offset===
19
end_offset===
21
Python OUTPUT===
Object l3, l4;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String s1 = new String(b1, "UTF-8");
red_line===
"UTF-8"
start_offset===
35
end_offset===
42
Python OUTPUT===
 String s1 = new String(b1, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Convert this Map to an EnumMap.
scn.ruleId===
1640
scn.suspCodeStr===
CustomHashMap<Size, Date> map3 = new CustomHashMap<Size, Date>();
red_line===
new CustomHashMap<Size, Date>()
start_offset===
45
end_offset===
76
Python OUTPUT===
 CustomHashMap<Size, Date> map3 = new CustomHashMap<Size, Date>(); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
final LinkedHashMap<String, Object> params = new LinkedHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
66
end_offset===
82
Python OUTPUT===
<> params = new LinkedHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"nullValue\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Object nullKey, nullValue, nullBoth;
red_line===
nullValue
start_offset===
24
end_offset===
33
Python OUTPUT===
Object nullKey, nullValue, nullBoth;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
enumMap = new EnumMap<Sequence, Integer>(Sequence.class);
red_line===
<Sequence, Integer>
start_offset===
33
end_offset===
52
Python OUTPUT===
<> Integer > ( Sequence.class ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
++i;
red_line===
i
start_offset===
22
end_offset===
23
Python OUTPUT===
++i;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
++i;
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
++i;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
++i;
red_line===
i
start_offset===
38
end_offset===
39
Python OUTPUT===
++i;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new CustomHashMap<K, V>();
red_line===
<K, V>
start_offset===
40
end_offset===
46
Python OUTPUT===
<> > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"e2\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Exception e1, e2;
red_line===
e2
start_offset===
22
end_offset===
24
Python OUTPUT===
Exception e1, e2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"v3\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
String k3 = null, v3 = null;
red_line===
v3
start_offset===
30
end_offset===
32
Python OUTPUT===
String k3 = null, v3 = null;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
two = new CustomArrayList<Size>();
red_line===
<Size>
start_offset===
37
end_offset===
43
Python OUTPUT===
<> < Size > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
cList2 = new ArrayList<Class>();
red_line===
<Class>
start_offset===
34
end_offset===
41
Python OUTPUT===
<> < Class > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
list = new ArrayList<Set<String>>();
red_line===
<Set<String>>
start_offset===
32
end_offset===
45
Python OUTPUT===
<> String >> ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
ArrayList<T> list = new ArrayList<T>();
red_line===
<T>
start_offset===
41
end_offset===
44
Python OUTPUT===
<> list = new ArrayList < T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<Zoo> list = new ArrayList<Zoo>();
red_line===
<Zoo>
start_offset===
38
end_offset===
43
Python OUTPUT===
<> list = new ArrayList < Zoo > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
protected List<Animal> animals = new ArrayList<Animal>();
red_line===
<Animal>
start_offset===
54
end_offset===
62
Python OUTPUT===
<> > animals = new ArrayList < Animal > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<Zoo> list = new ArrayList<Zoo>();
red_line===
<Zoo>
start_offset===
38
end_offset===
43
Python OUTPUT===
<> list = new ArrayList < Zoo > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strProtobufRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strProtobufRoundTrip = STRING.deser(protobufRoundTrip);
red_line===
= STRING.deser(protobufRoundTrip)
start_offset===
36
end_offset===
69
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println("registered short array delegate.");
red_line===
System.err
start_offset===
12
end_offset===
22
Python OUTPUT===
 System.err.println("registered short array delegate."); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
Strings and Boxed types should be compared using \"equals()\".
scn.ruleId===
4973
scn.suspCodeStr===
assertTrue(properName == elephant.properName);
red_line===
==
start_offset===
30
end_offset===
32
Python OUTPUT===
assertTrue(properName == elephant.properName);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"t2\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Throwable t1, t2;
red_line===
t2
start_offset===
22
end_offset===
24
Python OUTPUT===
Throwable t1, t2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this \"Byte\" constructor
scn.ruleId===
2129
scn.suspCodeStr===
allowNullValueMap.put(SomePojo.create("a"), new Byte((byte) 0));
red_line===
Byte
start_offset===
60
end_offset===
64
Python OUTPUT===
 allowNullValueMap.put(SomePojo.create("a"), new Byte((byte); 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
EnumMap<Order, Item> orderMap = new EnumMap<Order, Item>(Order.class);
red_line===
<Order, Item>
start_offset===
51
end_offset===
64
Python OUTPUT===
<> derMap = new EnumMap < Order , Item > ( Order.class ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"c1\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Class<?> c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10;
red_line===
c1
start_offset===
21
end_offset===
23
Python OUTPUT===
Class<?> c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"share12\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
Item share12 = new Item("share12");
red_line===
"share12"
start_offset===
32
end_offset===
41
Python OUTPUT===
Item share12 = new Item("share12");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"share7\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
Item share7 = new Item("share7");
red_line===
"share7"
start_offset===
31
end_offset===
39
Python OUTPUT===
Item share7 = new Item("share7");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
HashSet<T> set = new HashSet<T>();
red_line===
<T>
start_offset===
36
end_offset===
39
Python OUTPUT===
<> set = new HashSet < T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println(name);
red_line===
System.err
start_offset===
12
end_offset===
22
Python OUTPUT===
 System.err.println(name); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondMap\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
public Map firstMap, secondMap;
red_line===
secondMap
start_offset===
29
end_offset===
38
Python OUTPUT===
public Map firstMap, secondMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"share\" 16 times.
scn.ruleId===
1192
scn.suspCodeStr===
Item share = new Item("share");
red_line===
"share"
start_offset===
30
end_offset===
37
Python OUTPUT===
Item share = new Item("share");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondSet\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
public Set firstSet, secondSet;
red_line===
secondSet
start_offset===
29
end_offset===
38
Python OUTPUT===
public Set firstSet, secondSet;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make name a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public String name;
red_line===
name
start_offset===
22
end_offset===
26
Python OUTPUT===
public static final String name ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make firstList a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public List firstList, secondList;
red_line===
firstList
start_offset===
20
end_offset===
29
Python OUTPUT===
public static final List firstList , secondList ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new ArrayList<T>();
red_line===
<T>
start_offset===
28
end_offset===
31
Python OUTPUT===
<> T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"value\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final Object key = entry.getKey(), value = entry.getValue();
red_line===
value
start_offset===
51
end_offset===
56
Python OUTPUT===
final Object key = entry.getKey(), value = entry.getValue();
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Use \"BigDecimal.valueOf\" instead.
scn.ruleId===
2111
scn.suspCodeStr===
task.setBigDecimal(new BigDecimal(564654.234234d));
red_line===
new BigDecimal(564654.234234d)
start_offset===
27
end_offset===
57
Python OUTPUT===
task.setBigDecimal(new BigDecimal(564654.234234d));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make secondHashname a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public HasName firstHasName, secondHashname;
red_line===
secondHashname
start_offset===
37
end_offset===
51
Python OUTPUT===
public static final HasName firstHasName , secondHashname ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this assert with a proper check.
scn.ruleId===
4274
scn.suspCodeStr===
assert typeClass != null;
red_line===
assert typeClass != null;
start_offset===
8
end_offset===
33
Python OUTPUT===
 assert typeClass != null; 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"share5\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Item share4, share5;
red_line===
share5
start_offset===
21
end_offset===
27
Python OUTPUT===
Item share4, share5;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
38
end_offset===
54
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this use of System.out or System.err by a logger.
scn.ruleId===
106
scn.suspCodeStr===
System.err.println(RuntimeEnv.COLLECTION_SCHEMA_ON_REPEATED_FIELDS);
red_line===
System.err
start_offset===
8
end_offset===
18
Python OUTPUT===
 System.err.println(RuntimeEnv.COLLECTION_SCHEMA_ON_REPEATED_FIELDS); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Float\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Float(input.readFloat());
red_line===
Float
start_offset===
23
end_offset===
28
Python OUTPUT===
 return new Float(inputFloat()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setByte(message, (byte) input.readUInt32());
red_line===
f.setByte(message, (byte) input.readUInt32())
start_offset===
28
end_offset===
73
Python OUTPUT===
f.setByte(message, (byte) input.readUInt32());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setInt(message, input.readInt32());
red_line===
f.setInt(message, input.readInt32())
start_offset===
28
end_offset===
64
Python OUTPUT===
f.setInt(message, input.readInt32());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setLong(message, input.readInt64());
red_line===
f.setLong(message, input.readInt64())
start_offset===
28
end_offset===
65
Python OUTPUT===
f.setLong(message, input.readInt64());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make name a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public String name;
red_line===
name
start_offset===
22
end_offset===
26
Python OUTPUT===
public static final String name ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
The type of \"identityMap\" should be an interface such as \"Map\" rather than the implementation \"IdentityHashMap\".
scn.ruleId===
1319
scn.suspCodeStr===
public IdentityHashMap identityMap, anotherIdentityMap;
red_line===
IdentityHashMap
start_offset===
15
end_offset===
30
Python OUTPUT===
public IdentityHashMap identityMap, anotherIdentityMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setDouble(message, input.readDouble());
red_line===
f.setDouble(message, input.readDouble())
start_offset===
28
end_offset===
68
Python OUTPUT===
f.setDouble(message, input.readDouble());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, new BigDecimal(input.readString()));
red_line===
f.set(message, new BigDecimal(input.readString()))
start_offset===
24
end_offset===
74
Python OUTPUT===
f.set(message, new BigDecimal(input.readString()));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Date\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Date(input.readFixed64());
red_line===
Date
start_offset===
23
end_offset===
27
Python OUTPUT===
 return new Date(inputFixed64()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, value);
red_line===
f.set(message, value)
start_offset===
24
end_offset===
45
Python OUTPUT===
f.set(message, value);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Float\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Float(input.readFloat());
red_line===
Float
start_offset===
23
end_offset===
28
Python OUTPUT===
 return new Float(inputFloat()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, value);
red_line===
f.set(message, value)
start_offset===
24
end_offset===
45
Python OUTPUT===
f.set(message, value);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, new Date(input.readFixed64()));
red_line===
f.set(message, new Date(input.readFixed64()))
start_offset===
24
end_offset===
69
Python OUTPUT===
f.set(message, new Date(input.readFixed64()));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, new BigInteger(input.readByteArray()));
red_line===
f.set(message, new BigInteger(input.readByteArray()))
start_offset===
24
end_offset===
77
Python OUTPUT===
f.set(message, new BigInteger(input.readByteArray()));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
12
end_offset===
33
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondSetMap\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Map<Set<String>, ?> firstSetMap, secondSetMap;
red_line===
secondSetMap
start_offset===
41
end_offset===
53
Python OUTPUT===
Map<Set<String>, ?> firstSetMap, secondSetMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
IdentityHashMap<Order, Item> anotherIdentityMap = new IdentityHashMap<Order, Item>();
red_line===
<Order, Item>
start_offset===
77
end_offset===
90
Python OUTPUT===
<> = new IdentityHashMap < Order , Item > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondMapList\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
List<Map<String, ?>> firstMapList, secondMapList;
red_line===
secondMapList
start_offset===
43
end_offset===
56
Python OUTPUT===
List<Map<String, ?>> firstMapList, secondMapList;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondIntArray\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int[] firstIntArray, secondIntArray;
red_line===
secondIntArray
start_offset===
29
end_offset===
43
Python OUTPUT===
int[] firstIntArray, secondIntArray;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
IdentityHashMap<Item, Item> identityMap = new IdentityHashMap<Item, Item>();
red_line===
<Item, Item>
start_offset===
69
end_offset===
81
Python OUTPUT===
<> identityMap = new IdentityHashMap < Item , Item > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondItemArray\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Item[] firstItemArray, secondItemArray;
red_line===
secondItemArray
start_offset===
31
end_offset===
46
Python OUTPUT===
Item[] firstItemArray, secondItemArray;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make secondObject a static final constant or non-public and provide accessors if needed.
scn.ruleId===
1104
scn.suspCodeStr===
public Object firstObject, secondObject;
red_line===
secondObject
start_offset===
35
end_offset===
47
Python OUTPUT===
public static final Object firstObject , secondObject ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondNamed\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
public Named firstNamed, secondNamed;
red_line===
secondNamed
start_offset===
33
end_offset===
44
Python OUTPUT===
public Named firstNamed, secondNamed;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"secondListMap\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Map<List<Order>, ?> firstListMap, secondListMap;
red_line===
secondListMap
start_offset===
42
end_offset===
55
Python OUTPUT===
Map<List<Order>, ?> firstListMap, secondListMap;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
LinkedHashSet<Status> someEnumAsSet = new LinkedHashSet<Status>();
red_line===
<Status>
start_offset===
63
end_offset===
71
Python OUTPUT===
<> someEnumAsSet = new LinkedHashSet < Status > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
LinkedHashSet<Bar> someBarAsSet = new LinkedHashSet<Bar>();
red_line===
<Bar>
start_offset===
59
end_offset===
64
Python OUTPUT===
<> someBarAsSet = new LinkedHashSet < Bar > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
LinkedHashSet<Float> someFloatAsSet = new LinkedHashSet<Float>();
red_line===
<Float>
start_offset===
63
end_offset===
70
Python OUTPUT===
<> someFloatAsSet = new LinkedHashSet < Float > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace \"Collections.EMPTY_SET\" by \"Collections.emptySet()\".
scn.ruleId===
1596
scn.suspCodeStr===
((GraphInput) input).updateLast(Collections.EMPTY_SET, owner);
red_line===
Collections.EMPTY_SET
start_offset===
52
end_offset===
73
Python OUTPUT===
( ( GraphInput ) input ).updateLast ( Collections.EMPTY_SET , owner ) ;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"options\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
messageBlock.setAttribute("options", module.getOptions());
red_line===
"options"
start_offset===
34
end_offset===
43
Python OUTPUT===
messageBlock.setAttribute("options", module.getOptions());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"module\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
messageBlock.setAttribute("module", module);
red_line===
"module"
start_offset===
34
end_offset===
42
Python OUTPUT===
messageBlock.setAttribute("module", module);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this field \"__resolver\" to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
3008
scn.suspCodeStr===
private static GroupResolver __resolver = GROUP_RESOLVER;
red_line===
__resolver
start_offset===
33
end_offset===
43
Python OUTPUT===
private static GroupResolver __resolver = GROUP_RESOLVER;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"newInstance\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
Schema<T> schema = clazz.newInstance().cachedSchema();
red_line===
newInstance
start_offset===
33
end_offset===
44
Python OUTPUT===
 Schema<T> schema = clazz.newInstedSchema(); 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new LinkedHashMap<K, V>();
red_line===
<K, V>
start_offset===
32
end_offset===
38
Python OUTPUT===
<> > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protostuffStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protostuffStream = new ByteArrayInputStream(protostuff);
red_line===
= new ByteArrayInputStream(protostuff)
start_offset===
46
end_offset===
84
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<T> list = new ArrayList<T>();
red_line===
<T>
start_offset===
36
end_offset===
39
Python OUTPUT===
<> list = new ArrayList < T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException("Serializing to a byte array threw an IOException", e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException("Serializing to a byte array threw an IOException", e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
MESSAGE_FACTORIES_NAMES = new HashSet<String>(messageFactories.length);
red_line===
<String>
start_offset===
45
end_offset===
53
Python OUTPUT===
<> < String > ( messageFactories.length ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"wrapper\".
scn.ruleId===
1854
scn.suspCodeStr===
Registered<T> wrapper = new Registered<T>(id, schema, pipeSchema, strategy);
red_line===
= new Registered<T>(id, schema, pipeSchema, strategy)
start_offset===
34
end_offset===
87
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"enumIdStart\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final int pojoIdStart, enumIdStart, collectionIdStart, mapIdStart;
red_line===
enumIdStart
start_offset===
27
end_offset===
38
Python OUTPUT===
final int pojoIdStart, enumIdStart, collectionIdStart, mapIdStart;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"pipeSchema\" which hides the field declared at line 1054.
scn.ruleId===
1117
scn.suspCodeStr===
Pipe.Schema<T> pipeSchema = this.pipeSchema;
red_line===
pipeSchema
start_offset===
27
end_offset===
37
Python OUTPUT===
Pipe.Schema<T> pipeSchema = this.pipeSchema;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new ArrayList<T>();
red_line===
<T>
start_offset===
28
end_offset===
31
Python OUTPUT===
<> T > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"len\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int lastSize = session.size, len = str.length(), withIntOffset = lb.offset + 2;
red_line===
len
start_offset===
37
end_offset===
40
Python OUTPUT===
int lastSize = session.size, len = str.length(), withIntOffset = lb.offset + 2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"offset\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int limit = buffer.length, offset = lb.offset, i = 0;
red_line===
offset
start_offset===
35
end_offset===
41
Python OUTPUT===
int limit = buffer.length, offset = lb.offset, i = 0;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"o\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int existingOffset = offset, o = ++offset;
red_line===
o
start_offset===
45
end_offset===
46
Python OUTPUT===
int existingOffset = offset, o = ++offset;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = pad;
red_line===
outOffset++
start_offset===
23
end_offset===
34
Python OUTPUT===
 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"inOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
b1 = input[inOffset++];
red_line===
inOffset++
start_offset===
27
end_offset===
37
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"inOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
b0 = input[inOffset++];
red_line===
inOffset++
start_offset===
27
end_offset===
37
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = pad;
red_line===
outOffset++
start_offset===
23
end_offset===
34
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = (byte) (b0 << 2 | b1 >>> 4);
red_line===
outOffset++
start_offset===
31
end_offset===
42
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = (byte) (b1 << 4 | b2 >>> 2);
red_line===
outOffset++
start_offset===
31
end_offset===
42
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
output[outOffset++] = (byte) (b2 << 6 | b3);
red_line===
b3
start_offset===
56
end_offset===
58
Python OUTPUT===
output[outOffset++] = (byte) (b2 << 6 | b3);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = (byte) (b0 << 2 | b1 >>> 4);
red_line===
outOffset++
start_offset===
31
end_offset===
42
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"inOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
b0 = input[inOffset++];
red_line===
inOffset++
start_offset===
27
end_offset===
37
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = (byte) (b1 << 4 | b2 >>> 2);
red_line===
outOffset++
start_offset===
31
end_offset===
42
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"inOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
b0 = input[inOffset++];
red_line===
inOffset++
start_offset===
31
end_offset===
41
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
red_line===
limit
start_offset===
39
end_offset===
44
Python OUTPUT===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"stop\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
final int remaining = inLen % 3, stop = inOffset + (inLen - remaining);
red_line===
stop
start_offset===
41
end_offset===
45
Python OUTPUT===
final int remaining = inLen % 3, stop = inOffset + (inLen - remaining);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
red_line===
limit
start_offset===
39
end_offset===
44
Python OUTPUT===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
red_line===
limit
start_offset===
39
end_offset===
44
Python OUTPUT===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
red_line===
limit
start_offset===
39
end_offset===
44
Python OUTPUT===
int withoutPaddingLen = inLen, limit = inOffset + inLen;
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
output[outOffset++] = (byte) (b2 << 6 | b3);
red_line===
b3
start_offset===
56
end_offset===
58
Python OUTPUT===
output[outOffset++] = (byte) (b2 << 6 | b3);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"should not happen\" 6 times.
scn.ruleId===
1192
scn.suspCodeStr===
throw new IllegalStateException("should not happen");
red_line===
"should not happen"
start_offset===
48
end_offset===
67
Python OUTPUT===
throw new IllegalStateException("should not happen");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"inOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
b1 = input[inOffset++];
red_line===
inOffset++
start_offset===
31
end_offset===
41
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this assert with a proper check.
scn.ruleId===
4274
scn.suspCodeStr===
assert (output.length - outOffset) >= outLen;
red_line===
assert (output.length - outOffset) >= outLen;
start_offset===
8
end_offset===
53
Python OUTPUT===
 assert (output.length - outOffset) >= outLen; 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"outOffset\".
scn.ruleId===
1854
scn.suspCodeStr===
output[outOffset++] = (byte) (b0 << 2 | b1 >>> 4);
red_line===
outOffset++
start_offset===
31
end_offset===
42
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"b1\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
byte b0, b1, b2;
red_line===
b1
start_offset===
17
end_offset===
19
Python OUTPUT===
byte b0, b1, b2;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this assert with a proper check.
scn.ruleId===
4274
scn.suspCodeStr===
assert (output.length - outOffset) >= outLen;
red_line===
assert (output.length - outOffset) >= outLen;
start_offset===
8
end_offset===
53
Python OUTPUT===
 assert (output.length - outOffset) >= outLen; 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
int max_safe_pos = maxSafeDigits[radix] - 1;
red_line===
max_safe_pos
start_offset===
12
end_offset===
24
Python OUTPUT===
int max_safe_pos = maxSafeDigits[radix] - 1;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
int digit = Character.digit(buffer[offset++], radix);
red_line===
offset
start_offset===
47
end_offset===
53
Python OUTPUT===
int digit = Character.digit(buffer[offset++], radix);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unnecessary cast to \"int\".
scn.ruleId===
1905
scn.suspCodeStr===
int ch = (int) buffer[offset + i] & 0xff;
red_line===
int
start_offset===
26
end_offset===
29
Python OUTPUT===
 int ch = ( ) buffer[offset + i] & 0xff;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
buffer[offset++] = (byte) (0x80 | ((codePoint >> 12) & 0x3F));
red_line===
offset
start_offset===
23
end_offset===
29
Python OUTPUT===
buffer[offset++] = (byte) (0x80 | ((codePoint >> 12) & 0x3F));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String encodedString = new String(b64Encoded, "UTF-8");
red_line===
"UTF-8"
start_offset===
58
end_offset===
65
Python OUTPUT===
 String encodedString = new String(b64Encoded, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<Integer> a = new ArrayList<Integer>();
red_line===
<Integer>
start_offset===
39
end_offset===
48
Python OUTPUT===
<> a = new ArrayList < Integer > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
OutputStreamWriter writer = new OutputStreamWriter(out, "UTF-8");
red_line===
"UTF-8"
start_offset===
64
end_offset===
71
Python OUTPUT===
 OutputStreamWriter writer = new OutputStreamWriter(out, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] array = str.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
47
end_offset===
54
Python OUTPUT===
 byte[] array = str.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace this assert with a proper check.
scn.ruleId===
4274
scn.suspCodeStr===
assert start >= 0;
red_line===
assert start >= 0;
start_offset===
8
end_offset===
26
Python OUTPUT===
 assert start >= 0; 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] builtin = str.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
49
end_offset===
56
Python OUTPUT===
 byte[] builtin = str.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] decodedFromString = B64Code.decode(new String(b64Encoded, "UTF-8"));
red_line===
"UTF-8"
start_offset===
77
end_offset===
84
Python OUTPUT===
 byte[] decodedFromString = B64Code.decode(new String(b64Encoded, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unused \"lenA\" local variable.
scn.ruleId===
1481
scn.suspCodeStr===
int lenA = a.length();
red_line===
lenA
start_offset===
16
end_offset===
20
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String three_byte_utf8 = "\u1234\u8000\uF800\u0800";
red_line===
three_byte_utf8
start_offset===
24
end_offset===
39
Python OUTPUT===
static final String three_byte_utf8 = "\u1234\u8000\uF800\u0800";
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8"));
red_line===
"UTF-8"
start_offset===
60
end_offset===
67
Python OUTPUT===
 byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String alphabet_to_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
red_line===
alphabet_to_upper
start_offset===
24
end_offset===
41
Python OUTPUT===
static final String alphabet_to_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Make \"targetMessage\" transient or serializable.
scn.ruleId===
1948
scn.suspCodeStr===
public final Object targetMessage;
red_line===
targetMessage
start_offset===
24
end_offset===
37
Python OUTPUT===
public final Object targetMessage ;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] decodedFromString = B64Code.decode(new String(b64Encoded, "UTF-8"));
red_line===
"UTF-8"
start_offset===
77
end_offset===
84
Python OUTPUT===
 byte[] decodedFromString = B64Code.decode(new String(b64Encoded, "UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Extract the assignment out of this expression.
scn.ruleId===
1121
scn.suspCodeStr===
result |= (tmp = buffer[offset++]) << 28;
red_line===
=
start_offset===
35
end_offset===
36
Python OUTPUT===
result |= (tmp = buffer[offset++]) << 28;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8"));
red_line===
"UTF-8"
start_offset===
60
end_offset===
67
Python OUTPUT===
 byte[] b64Encoded = B64Code.encode(str.getBytes("UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_grow = session2.toByteArray();
red_line===
buffered_needed_to_grow
start_offset===
19
end_offset===
42
Python OUTPUT===
byte[] buffered_needed_to_grow = session2.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
verifyRoundTrip(str.getBytes("UTF-8"));
red_line===
"UTF-8"
start_offset===
41
end_offset===
48
Python OUTPUT===
 verifyRoundTrip(str.getBytes("UTF-8")); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"1234567\" 12 times.
scn.ruleId===
1192
scn.suspCodeStr===
testStream("1234567", new LinkedBuffer(12));
red_line===
"1234567"
start_offset===
19
end_offset===
28
Python OUTPUT===
testStream("1234567", new LinkedBuffer(12));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"buffered\".
scn.ruleId===
1854
scn.suspCodeStr===
buffered = session.toByteArray();
red_line===
= session.toByteArray()
start_offset===
17
end_offset===
40
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
byte[] builtin = str.toString().getBytes("UTF-8");
red_line===
"UTF-8"
start_offset===
49
end_offset===
56
Python OUTPUT===
 byte[] builtin = str.toString().getBytes("UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.US_ASCII
scn.ruleId===
4719
scn.suspCodeStr===
String strBuiltin = new String(builtin, "ASCII");
red_line===
"ASCII"
start_offset===
48
end_offset===
55
Python OUTPUT===
 String strBuiltin = new String(builtin, "ASCII"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.US_ASCII
scn.ruleId===
4719
scn.suspCodeStr===
String strBuffered = new String(buffered, "ASCII");
red_line===
"ASCII"
start_offset===
50
end_offset===
57
Python OUTPUT===
 String strBuffered = new String(buffered, "ASCII"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String two_byte_utf8 = "\u07FF\341\210\264";
red_line===
two_byte_utf8
start_offset===
24
end_offset===
37
Python OUTPUT===
static final String two_byte_utf8 = "\u07FF\341\210\264";
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String strBuiltin = new String(builtin, "UTF-8");
red_line===
"UTF-8"
start_offset===
48
end_offset===
55
Python OUTPUT===
 String strBuiltin = new String(builtin, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String numeric = "0123456789";
red_line===
numeric
start_offset===
24
end_offset===
31
Python OUTPUT===
static final String numeric = "0123456789";
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace charset name argument with StandardCharsets.UTF_8
scn.ruleId===
4719
scn.suspCodeStr===
String strBuffered = new String(buffered, "UTF-8");
red_line===
"UTF-8"
start_offset===
50
end_offset===
57
Python OUTPUT===
 String strBuffered = new String(buffered, "UTF-8"); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String whitespace = "\r\n\t";
red_line===
whitespace
start_offset===
24
end_offset===
34
Python OUTPUT===
static final String whitespace = "\r\n\t";
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this constant name to match the regular expression \u0027^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\u0027.
scn.ruleId===
115
scn.suspCodeStr===
static final String foo = alphabet + three_byte_utf8 + numeric + two_byte_utf8 + whitespace + surrogatePairs;
red_line===
foo
start_offset===
24
end_offset===
27
Python OUTPUT===
static final String foo = alphabet + three_byte_utf8 + numeric + two_byte_utf8 + whitespace + surrogatePairs;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_grow = session2.toByteArray();
red_line===
buffered_needed_to_grow
start_offset===
19
end_offset===
42
Python OUTPUT===
byte[] buffered_needed_to_grow = session2.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"limit\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int offset, limit;
red_line===
limit
start_offset===
16
end_offset===
21
Python OUTPUT===
int offset, limit;
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"optional\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(test.getField("optional").number == 1);
red_line===
"optional"
start_offset===
33
end_offset===
43
Python OUTPUT===
assertTrue(test.getField("optional").number == 1);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"option\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(test.getField("option").number == 33);
red_line===
"option"
start_offset===
33
end_offset===
41
Python OUTPUT===
assertTrue(test.getField("option").number == 33);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Deeper\" 8 times.
scn.ruleId===
1192
scn.suspCodeStr===
Message requestDeeper = requestInner.getNestedMessage("Deeper");
red_line===
"Deeper"
start_offset===
62
end_offset===
70
Python OUTPUT===
Message requestDeeper = requestInner.getNestedMessage("Deeper");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"____Foo____Bar___Baz____\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals("fooBarBaz", toCamelCase("____Foo____Bar___Baz____").toString());
red_line===
"____Foo____Bar___Baz____"
start_offset===
46
end_offset===
72
Python OUTPUT===
assertEquals("fooBarBaz", toCamelCase("____Foo____Bar___Baz____").toString());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Bool bar_some_boolean = (Field.Bool) bar.getField("some_boolean");
red_line===
bar_some_boolean
start_offset===
19
end_offset===
35
Python OUTPUT===
Field.Bool bar_some_boolean = (Field.Bool) bar.getField("some_boolean");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Double bar_some_double = (Field.Double) bar.getField("some_double");
red_line===
bar_some_double
start_offset===
21
end_offset===
36
Python OUTPUT===
Field.Double bar_some_double = (Field.Double) bar.getField("some_double");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int64 baz_timestamp = (Field.Int64) baz.getField("timestamp");
red_line===
baz_timestamp
start_offset===
20
end_offset===
33
Python OUTPUT===
Field.Int64 baz_timestamp = (Field.Int64) baz.getField("timestamp");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Bytes baz_data = (Field.Bytes) baz.getField("data");
red_line===
baz_data
start_offset===
20
end_offset===
28
Python OUTPUT===
Field.Bytes baz_data = (Field.Bytes) baz.getField("data");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
byte[] buffered_needed_to_flush = out2.toByteArray();
red_line===
buffered_needed_to_flush
start_offset===
19
end_offset===
43
Python OUTPUT===
byte[] buffered_needed_to_flush = out2.toByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int32 foo_some_int = (Field.Int32) foo.getField("some_int");
red_line===
foo_some_int
start_offset===
20
end_offset===
32
Python OUTPUT===
Field.Int32 foo_some_int = (Field.Int32) foo.getField("some_int");
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
MessageField foo_bar = (MessageField) foo.getField("bar");
red_line===
foo_bar
start_offset===
21
end_offset===
28
Python OUTPUT===
MessageField foo_bar = (MessageField) foo.getField("bar");
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
EnumField foo_some_enum = (EnumField) foo.getField("some_enum");
red_line===
foo_some_enum
start_offset===
18
end_offset===
31
Python OUTPUT===
EnumField foo_some_enum = (EnumField) foo.getField("some_enum");
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Bytes foo_some_bytes = (Field.Bytes) foo.getField("some_bytes");
red_line===
foo_some_bytes
start_offset===
20
end_offset===
34
Python OUTPUT===
Field.Bytes foo_some_bytes = (Field.Bytes) foo.getField("some_bytes");
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
Prevent \"int\" promotion by adding \"\u0026 0xff\" to this expression.
scn.ruleId===
3034
scn.suspCodeStr===
final int size = buffer[offset++] | (buffer[offset++] << 8);
red_line===
buffer[offset++]
start_offset===
25
end_offset===
41
Python OUTPUT===
final int size = buffer[offset++] | (buffer[offset++] << 8);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int64 foo_some_long = (Field.Int64) foo.getField("some_long");
red_line===
foo_some_long
start_offset===
20
end_offset===
33
Python OUTPUT===
Field.Int64 foo_some_long = (Field.Int64) foo.getField("some_long");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
MessageField bar_baz = (MessageField) bar.getField("baz");
red_line===
bar_baz
start_offset===
21
end_offset===
28
Python OUTPUT===
MessageField bar_baz = (MessageField) bar.getField("baz");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
EnumField bar_some_enum = (EnumField) bar.getField("some_enum");
red_line===
bar_some_enum
start_offset===
18
end_offset===
31
Python OUTPUT===
EnumField bar_some_enum = (EnumField) bar.getField("some_enum");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Bytes bar_some_bytes = (Field.Bytes) bar.getField("some_bytes");
red_line===
bar_some_bytes
start_offset===
20
end_offset===
34
Python OUTPUT===
Field.Bytes bar_some_bytes = (Field.Bytes) bar.getField("some_bytes");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Float bar_some_float = (Field.Float) bar.getField("some_float");
red_line===
bar_some_float
start_offset===
20
end_offset===
34
Python OUTPUT===
Field.Float bar_some_float = (Field.Float) bar.getField("some_float");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int64 baz_id = (Field.Int64) baz.getField("id");
red_line===
baz_id
start_offset===
20
end_offset===
26
Python OUTPUT===
Field.Int64 baz_id = (Field.Int64) baz.getField("id");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.String baz_name = (Field.String) baz.getField("name");
red_line===
baz_name
start_offset===
21
end_offset===
29
Python OUTPUT===
Field.String baz_name = (Field.String) baz.getField("name");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Message tnmhb_nestedMessage = testNestedMessageHasBits.getNestedMessage("NestedMessage");
red_line===
tnmhb_nestedMessage
start_offset===
16
end_offset===
35
Python OUTPUT===
Message tnmhb_nestedMessage = testNestedMessageHasBits.getNestedMessage("NestedMessage");
isFixed===
false
==================
RuleType===
BUG
scn.errorMessage===
A \"NullPointerException\" could be thrown; \"data\" is nullable here.
scn.ruleId===
2259
scn.suspCodeStr===
assertTrue((data[0] & 0xFF) == 0xFA);
red_line===
data
start_offset===
20
end_offset===
24
Python OUTPUT===
assertTrue((data[0] & 0xFF) == 0xFA);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.String bar_some_string = (Field.String) bar.getField("some_string");
red_line===
bar_some_string
start_offset===
21
end_offset===
36
Python OUTPUT===
Field.String bar_some_string = (Field.String) bar.getField("some_string");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename this local variable to match the regular expression \u0027^[a-z][a-zA-Z0-9]*$\u0027.
scn.ruleId===
117
scn.suspCodeStr===
Field.Int32 import_message_d = (Field.Int32) importMessage.getField("d");
red_line===
import_message_d
start_offset===
20
end_offset===
36
Python OUTPUT===
Field.Int32 import_message_d = (Field.Int32) importMessage.getField("d");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
location.networkLocations = new java.util.HashSet<Ent_NetworkLocation>();
red_line===
<Ent_NetworkLocation>
start_offset===
57
end_offset===
78
Python OUTPUT===
<> new java.util.HashSet < Ent_NetworkLocation > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"writes\" and all following declarations on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int reads, writes, transfers;
red_line===
writes
start_offset===
19
end_offset===
25
Python OUTPUT===
int reads, writes, transfers;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"last\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
private T current, last;
red_line===
last
start_offset===
23
end_offset===
27
Python OUTPUT===
private T current, last;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
buffer[offset++] = (byte) ((s >>> 0) & 0xFF);
red_line===
offset
start_offset===
23
end_offset===
29
Python OUTPUT===
buffer[offset++] = (byte) ((s >>> 0) & 0xFF);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"len\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
int pos = 0, len = input.length();
red_line===
len
start_offset===
21
end_offset===
24
Python OUTPUT===
int pos = 0, len = input.length();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
buffer[offset++] = (byte) ((s >>> 8) & 0xFF);
red_line===
offset
start_offset===
23
end_offset===
29
Python OUTPUT===
buffer[offset++] = (byte) ((s >>> 8) & 0xFF);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
s[i] = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));
red_line===
offset
start_offset===
40
end_offset===
46
Python OUTPUT===
s[i] = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
++i;
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
++i;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strProtobufRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strProtobufRoundTrip = STRING.deser(protobufRoundTrip);
red_line===
= STRING.deser(protobufRoundTrip)
start_offset===
36
end_offset===
69
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
network.networkLocations = new java.util.HashSet<Ent_NetworkLocation>();
red_line===
<Ent_NetworkLocation>
start_offset===
56
end_offset===
77
Python OUTPUT===
<> new java.util.HashSet < Ent_NetworkLocation > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<Payment> list = new ArrayList<Payment>();
red_line===
<Payment>
start_offset===
42
end_offset===
51
Python OUTPUT===
<> list = new ArrayList < Payment > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this unnecessary cast to \"MainData\".
scn.ruleId===
1905
scn.suspCodeStr===
verifyEquals(testdata, (MainData)objParsed.list.get(0));
red_line===
MainData
start_offset===
32
end_offset===
40
Python OUTPUT===
 verifyEquals(testdata, (MainDatsed.list.get(0)); 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
olist = new ArrayList<Object>();
red_line===
<Object>
start_offset===
33
end_offset===
41
Python OUTPUT===
<> < Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Do not forget to remove this deprecated code someday.
scn.ruleId===
1133
scn.suspCodeStr===
String alias;
red_line===
alias
start_offset===
15
end_offset===
20
Python OUTPUT===
String alias;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
omap = new HashMap<String, Object>();
red_line===
<String, Object>
start_offset===
30
end_offset===
46
Python OUTPUT===
<> Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
protected ConcurrentHashMap<String, Object> voProperties = new ConcurrentHashMap<String, Object>();
red_line===
<String, Object>
start_offset===
88
end_offset===
104
Python OUTPUT===
<> voProperties = new ConcurrentHashMap < String , Object > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"strProtobufRoundTrip\".
scn.ruleId===
1854
scn.suspCodeStr===
String strProtobufRoundTrip = STRING.deser(protobufRoundTrip);
red_line===
= STRING.deser(protobufRoundTrip)
start_offset===
36
end_offset===
69
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"alias\" 4 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertTrue(schema.getFieldNumber("alias") == 0);
red_line===
"alias"
start_offset===
41
end_offset===
48
Python OUTPUT===
assertTrue(schema.getFieldNumber("alias") == 0);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"timestamp\" 5 times.
scn.ruleId===
1192
scn.suspCodeStr===
assertEquals(schema.getFields().get(2).name, "timestamp");
red_line===
"timestamp"
start_offset===
53
end_offset===
64
Python OUTPUT===
assertEquals(schema.getFields().get(2).name, "timestamp");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobuf\".
scn.ruleId===
1854
scn.suspCodeStr===
byte[] protobuf = ProtobufIOUtil.toByteArray(message, schema, buf());
red_line===
= ProtobufIOUtil.toByteArray(message, schema, buf())
start_offset===
24
end_offset===
76
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"protobufStream\".
scn.ruleId===
1854
scn.suspCodeStr===
ByteArrayInputStream protobufStream = new ByteArrayInputStream(protobuf);
red_line===
= new ByteArrayInputStream(protobuf)
start_offset===
44
end_offset===
80
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"parsedMessage\".
scn.ruleId===
1854
scn.suspCodeStr===
T parsedMessage = schema.newMessage();
red_line===
= schema.newMessage()
start_offset===
24
end_offset===
45
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Add the missing @deprecated Javadoc tag.
scn.ruleId===
1123
scn.suspCodeStr===
boolean g;
red_line===
g
start_offset===
16
end_offset===
17
Python OUTPUT===
boolean g;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove the \"transient\" modifier from this field.
scn.ruleId===
2065
scn.suspCodeStr===
transient int someInt;
red_line===
transient
start_offset===
8
end_offset===
17
Python OUTPUT===
 transiemeInt; 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Declare \"e2\" on a separate line.
scn.ruleId===
1659
scn.suspCodeStr===
Map.Entry<BB[], String> e1 = it21.next(), e2 = it22.next();
red_line===
e2
start_offset===
54
end_offset===
56
Python OUTPUT===
Map.Entry<BB[], String> e1 = it21.next(), e2 = it22.next();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
linkedList = new LinkedList<String>();
red_line===
<String>
start_offset===
39
end_offset===
47
Python OUTPUT===
<> < String > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"!unknown!\".
scn.ruleId===
1854
scn.suspCodeStr===
final int first = input.readFieldNumber(DerivativeSchema.this);
red_line===
= input.readFieldNumber(DerivativeSchema.this)
start_offset===
28
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Rename \"preserveNull\" which hides the field declared at line 87.
scn.ruleId===
1117
scn.suspCodeStr===
final boolean preserveNull = IdStrategy.this.preserveNull;
red_line===
preserveNull
start_offset===
30
end_offset===
42
Python OUTPUT===
final boolean preserveNull = IdStrategy.this.preserveNull;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<InputDevice> devices = new ArrayList<InputDevice>();
red_line===
<InputDevice>
start_offset===
49
end_offset===
62
Python OUTPUT===
<> devices = new ArrayList < InputDevice > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"number\".
scn.ruleId===
1854
scn.suspCodeStr===
final int number = input.readFieldNumber(pipeSchema.wrappedSchema);
red_line===
= input.readFieldNumber(pipeSchema.wrappedSchema)
start_offset===
25
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define a constant instead of duplicating this literal \"Should not happen.\" 3 times.
scn.ruleId===
1192
scn.suspCodeStr===
throw new RuntimeException("Should not happen.");
red_line===
"Should not happen."
start_offset===
43
end_offset===
63
Python OUTPUT===
throw new RuntimeException("Should not happen.");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readBool();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readBool();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.mergeObject(null, hs.getSchema());
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.mergeObject(null, hs.getSchema());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
nullCount = input.readUInt32();
red_line===
nullCount
start_offset===
28
end_offset===
37
Python OUTPUT===
nullCount = input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = (short) input.readUInt32();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = (short) input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = delegate.readFrom(input);
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = delegate.readFrom(input);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException("Should not happen.");
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException("Should not happen.");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException("Should not happen.");
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException("Should not happen.");
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += nullCount;
red_line===
i
start_offset===
28
end_offset===
29
Python OUTPUT===
i += nullCount;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readByteArray();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readByteArray();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += nullCount;
red_line===
i
start_offset===
20
end_offset===
21
Python OUTPUT===
i += nullCount;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
nullCount = input.readUInt32();
red_line===
nullCount
start_offset===
20
end_offset===
29
Python OUTPUT===
nullCount = input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = (char) input.readUInt32();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = (char) input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readString();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readString();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = new Date(input.readFixed64());
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = new Date(input.readFixed64());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readInt32();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readInt64();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readInt64();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = eio.readFrom(input);
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = eio.readFrom(input);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readBytes();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readBytes();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i++;
red_line===
i
start_offset===
28
end_offset===
29
Python OUTPUT===
i++;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readFloat();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readFloat();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i++;
red_line===
i
start_offset===
20
end_offset===
21
Python OUTPUT===
i++;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = input.readDouble();
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = input.readDouble();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += nullCount;
red_line===
i
start_offset===
28
end_offset===
29
Python OUTPUT===
i += nullCount;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = new BigInteger(input.readByteArray());
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = new BigInteger(input.readByteArray());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
nullCount = input.readUInt32();
red_line===
nullCount
start_offset===
28
end_offset===
37
Python OUTPUT===
nullCount = input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"!unknown!\".
scn.ruleId===
1854
scn.suspCodeStr===
final int len = input.readInt32();
red_line===
= input.readInt32()
start_offset===
30
end_offset===
49
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i += input.readUInt32();
red_line===
i
start_offset===
24
end_offset===
25
Python OUTPUT===
i += input.readUInt32();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
i++;
red_line===
i
start_offset===
28
end_offset===
29
Python OUTPUT===
i++;
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Refactor the code in order to not assign to this loop counter from within the loop body.
scn.ruleId===
127
scn.suspCodeStr===
array[i++] = new BigDecimal(input.readString());
red_line===
i
start_offset===
30
end_offset===
31
Python OUTPUT===
array[i++] = new BigDecimal(input.readString());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, value);
red_line===
f.set(message, value)
start_offset===
28
end_offset===
49
Python OUTPUT===
f.set(message, value);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, input.readByteArray());
red_line===
f.set(message, input.readByteArray())
start_offset===
24
end_offset===
61
Python OUTPUT===
f.set(message, input.readByteArray());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
22
end_offset===
38
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setShort(message, (short) input.readUInt32());
red_line===
f.setShort(message, (short) input.readUInt32())
start_offset===
28
end_offset===
75
Python OUTPUT===
f.setShort(message, (short) input.readUInt32());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
valueByAliasMap = new HashMap<String, E>(n * 2);
red_line===
<String, E>
start_offset===
37
end_offset===
48
Python OUTPUT===
<> E > ( n * 2 ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
valueByTagMap = new HashMap<Integer, E>(n * 2);
red_line===
<Integer, E>
start_offset===
35
end_offset===
47
Python OUTPUT===
<> E > ( n * 2 ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
keyTypeFromMap.setAccessible(true);
red_line===
keyTypeFromMap.setAccessible(true)
start_offset===
12
end_offset===
46
Python OUTPUT===
keyTypeFromMap.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
List<InputDevice> devices = new ArrayList<InputDevice>();
red_line===
<InputDevice>
start_offset===
49
end_offset===
62
Python OUTPUT===
<> devices = new ArrayList < InputDevice > ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setChar(message, (char) input.readUInt32());
red_line===
f.setChar(message, (char) input.readUInt32())
start_offset===
28
end_offset===
73
Python OUTPUT===
f.setChar(message, (char) input.readUInt32());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setFloat(message, input.readFloat());
red_line===
f.setFloat(message, input.readFloat())
start_offset===
28
end_offset===
66
Python OUTPUT===
f.setFloat(message, input.readFloat());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, value);
red_line===
f.set(message, value)
start_offset===
28
end_offset===
49
Python OUTPUT===
f.set(message, value);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
38
end_offset===
54
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
38
end_offset===
54
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, input.readString());
red_line===
f.set(message, input.readString())
start_offset===
24
end_offset===
58
Python OUTPUT===
f.set(message, input.readString());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, value);
red_line===
f.set(message, value)
start_offset===
24
end_offset===
45
Python OUTPUT===
f.set(message, value);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
38
end_offset===
54
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, input.readBytes());
red_line===
f.set(message, input.readBytes())
start_offset===
24
end_offset===
57
Python OUTPUT===
f.set(message, input.readBytes());
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Date\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
us.putObject(message, offset, new Date(input.readFixed64()));
red_line===
Date
start_offset===
54
end_offset===
58
Python OUTPUT===
 us.putObject(message, offset, new Date(input.readFixe))); 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Double\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Double(input.readDouble());
red_line===
Double
start_offset===
23
end_offset===
29
Python OUTPUT===
 return new Double(inpuDouble()); 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Use classes from the Java API instead of Sun classes.
scn.ruleId===
1191
scn.suspCodeStr===
static final sun.misc.Unsafe us = initUnsafe();
red_line===
sun.misc.Unsafe
start_offset===
17
end_offset===
32
Python OUTPUT===
static final sun.misc.Unsafe us = initUnsafe();
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this use of \"Date\"; it is deprecated.
scn.ruleId===
1874
scn.suspCodeStr===
return new Date(input.readFixed64());
red_line===
Date
start_offset===
23
end_offset===
27
Python OUTPUT===
 return new Date(inputFixed64()); 
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.setAccessible(true);
red_line===
f.setAccessible(true)
start_offset===
20
end_offset===
41
Python OUTPUT===
f.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
f.set(message, eio.readFrom(input));
red_line===
f.set(message, eio.readFrom(input))
start_offset===
24
end_offset===
59
Python OUTPUT===
f.set(message, eio.readFrom(input));
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
30
end_offset===
46
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
26
end_offset===
42
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility update should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
cause.setAccessible(true);
red_line===
cause.setAccessible(true)
start_offset===
16
end_offset===
41
Python OUTPUT===
cause.setAccessible(true);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
This accessibility bypass should be removed.
scn.ruleId===
3011
scn.suspCodeStr===
__cause.set(pojo, cause);
red_line===
__cause.set(pojo, cause)
start_offset===
20
end_offset===
44
Python OUTPUT===
__cause.set(pojo, cause);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
30
end_offset===
46
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Remove this useless assignment to local variable \"number\".
scn.ruleId===
1854
scn.suspCodeStr===
final int number = input.readFieldNumber(pipeSchema.wrappedSchema);
red_line===
= input.readFieldNumber(pipeSchema.wrappedSchema)
start_offset===
25
end_offset===
74
Python OUTPUT===
 
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
30
end_offset===
46
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(e);
red_line===
RuntimeException
start_offset===
30
end_offset===
46
Python OUTPUT===
throw new RuntimeException(e);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
private static final HashMap<String, RuntimeFieldFactory<?>> __inlineValues = new HashMap<String, RuntimeFieldFactory<?>>();
red_line===
<String, RuntimeFieldFactory<?>>
start_offset===
93
end_offset===
125
Python OUTPUT===
<> >> _ _ inlineValues = new HashMap < String , RuntimeFieldFactory < ? >> ( ) ;
isFixed===
true
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Define and throw a dedicated exception instead of using a generic one.
scn.ruleId===
112
scn.suspCodeStr===
throw new RuntimeException(message);
red_line===
RuntimeException
start_offset===
34
end_offset===
50
Python OUTPUT===
throw new RuntimeException(message);
isFixed===
false
==================
RuleType===
CODE_SMELL
scn.errorMessage===
Replace the type specification in this constructor call with the diamond operator (\"\u003c\u003e\"). (sonar.java.source not set. Assuming 7 or greater.)
scn.ruleId===
2293
scn.suspCodeStr===
return new ArrayFieldMap<T>(fields, lastFieldNumber);
red_line===
<T>
start_offset===
26
end_offset===
29
Python OUTPUT===
<> T > ( fields , lastFieldNumber ) ;
isFixed===
true
==================
